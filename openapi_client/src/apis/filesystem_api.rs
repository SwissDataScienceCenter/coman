/*
 * FirecREST
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.4.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};


/// struct for typed errors of method [`compress_filesystem_system_name_transfer_compress_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompressFilesystemSystemNameTransferCompressPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`compress_filesystem_system_name_transfer_compress_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompressFilesystemSystemNameTransferCompressPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rm_filesystem_system_name_ops_rm_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRmFilesystemSystemNameOpsRmDeleteError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rm_filesystem_system_name_ops_rm_delete_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRmFilesystemSystemNameOpsRmDelete0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rm_filesystem_system_name_transfer_rm_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRmFilesystemSystemNameTransferRmDeleteError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rm_filesystem_system_name_transfer_rm_delete_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRmFilesystemSystemNameTransferRmDelete0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_filesystem_system_name_transfer_extract_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractFilesystemSystemNameTransferExtractPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_filesystem_system_name_transfer_extract_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractFilesystemSystemNameTransferExtractPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_checksum_filesystem_system_name_ops_checksum_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChecksumFilesystemSystemNameOpsChecksumGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_checksum_filesystem_system_name_ops_checksum_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChecksumFilesystemSystemNameOpsChecksumGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_download_filesystem_system_name_ops_download_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDownloadFilesystemSystemNameOpsDownloadGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_download_filesystem_system_name_ops_download_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDownloadFilesystemSystemNameOpsDownloadGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_filesystem_system_name_ops_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileFilesystemSystemNameOpsFileGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_filesystem_system_name_ops_file_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileFilesystemSystemNameOpsFileGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_head_filesystem_system_name_ops_head_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHeadFilesystemSystemNameOpsHeadGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_head_filesystem_system_name_ops_head_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHeadFilesystemSystemNameOpsHeadGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ls_filesystem_system_name_ops_ls_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLsFilesystemSystemNameOpsLsGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ls_filesystem_system_name_ops_ls_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLsFilesystemSystemNameOpsLsGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stat_filesystem_system_name_ops_stat_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStatFilesystemSystemNameOpsStatGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stat_filesystem_system_name_ops_stat_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStatFilesystemSystemNameOpsStatGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tail_filesystem_system_name_ops_tail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTailFilesystemSystemNameOpsTailGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tail_filesystem_system_name_ops_tail_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTailFilesystemSystemNameOpsTailGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_view_filesystem_system_name_ops_view_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetViewFilesystemSystemNameOpsViewGetError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_view_filesystem_system_name_ops_view_get_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetViewFilesystemSystemNameOpsViewGet0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_mv_filesystem_system_name_transfer_mv_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveMvFilesystemSystemNameTransferMvPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_mv_filesystem_system_name_transfer_mv_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveMvFilesystemSystemNameTransferMvPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_compress_filesystem_system_name_ops_compress_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCompressFilesystemSystemNameOpsCompressPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_compress_filesystem_system_name_ops_compress_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCompressFilesystemSystemNameOpsCompressPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_cp_filesystem_system_name_transfer_cp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCpFilesystemSystemNameTransferCpPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_cp_filesystem_system_name_transfer_cp_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCpFilesystemSystemNameTransferCpPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_download_filesystem_system_name_transfer_download_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostDownloadFilesystemSystemNameTransferDownloadPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_download_filesystem_system_name_transfer_download_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostDownloadFilesystemSystemNameTransferDownloadPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_extract_filesystem_system_name_ops_extract_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostExtractFilesystemSystemNameOpsExtractPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_extract_filesystem_system_name_ops_extract_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostExtractFilesystemSystemNameOpsExtractPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_mkdir_filesystem_system_name_ops_mkdir_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMkdirFilesystemSystemNameOpsMkdirPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_mkdir_filesystem_system_name_ops_mkdir_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostMkdirFilesystemSystemNameOpsMkdirPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_symlink_filesystem_system_name_ops_symlink_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSymlinkFilesystemSystemNameOpsSymlinkPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_symlink_filesystem_system_name_ops_symlink_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostSymlinkFilesystemSystemNameOpsSymlinkPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_upload_filesystem_system_name_ops_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUploadFilesystemSystemNameOpsUploadPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_upload_filesystem_system_name_ops_upload_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUploadFilesystemSystemNameOpsUploadPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_upload_filesystem_system_name_transfer_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUploadFilesystemSystemNameTransferUploadPostError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_upload_filesystem_system_name_transfer_upload_post_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUploadFilesystemSystemNameTransferUploadPost0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_chmod_filesystem_system_name_ops_chmod_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutChmodFilesystemSystemNameOpsChmodPutError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_chmod_filesystem_system_name_ops_chmod_put_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutChmodFilesystemSystemNameOpsChmodPut0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_chown_filesystem_system_name_ops_chown_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutChownFilesystemSystemNameOpsChownPutError {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_chown_filesystem_system_name_ops_chown_put_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutChownFilesystemSystemNameOpsChownPut0Error {
    Status4XX(models::ApiResponseError),
    Status5XX(models::ApiResponseError),
    UnknownValue(serde_json::Value),
}


/// Create compress file or directory operation (`tar`) (for files larger than 5242880 Bytes)
pub async fn compress_filesystem_system_name_transfer_compress_post(configuration: &configuration::Configuration, system_name: &str, compress_request: models::CompressRequest) -> Result<models::CompressResponse, Error<CompressFilesystemSystemNameTransferCompressPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_compress_request = compress_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/compress", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_compress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompressResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompressResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompressFilesystemSystemNameTransferCompressPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create compress file or directory operation (`tar`) (for files larger than 5242880 Bytes)
pub async fn compress_filesystem_system_name_transfer_compress_post_0(configuration: &configuration::Configuration, system_name: &str, compress_request: models::CompressRequest) -> Result<models::CompressResponse, Error<CompressFilesystemSystemNameTransferCompressPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_compress_request = compress_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/compress", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_compress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompressResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompressResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompressFilesystemSystemNameTransferCompressPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete file or directory operation (`rm`)
pub async fn delete_rm_filesystem_system_name_ops_rm_delete(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<(), Error<DeleteRmFilesystemSystemNameOpsRmDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/rm", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRmFilesystemSystemNameOpsRmDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete file or directory operation (`rm`)
pub async fn delete_rm_filesystem_system_name_ops_rm_delete_0(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<(), Error<DeleteRmFilesystemSystemNameOpsRmDelete0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/rm", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRmFilesystemSystemNameOpsRmDelete0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create remove file or directory operation (`rm`) (for files larger than 5242880 Bytes)
pub async fn delete_rm_filesystem_system_name_transfer_rm_delete(configuration: &configuration::Configuration, system_name: &str, path: &str, account: Option<&str>) -> Result<models::DeleteResponse, Error<DeleteRmFilesystemSystemNameTransferRmDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_account = account;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/rm", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_account {
        req_builder = req_builder.query(&[("account", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRmFilesystemSystemNameTransferRmDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create remove file or directory operation (`rm`) (for files larger than 5242880 Bytes)
pub async fn delete_rm_filesystem_system_name_transfer_rm_delete_0(configuration: &configuration::Configuration, system_name: &str, path: &str, account: Option<&str>) -> Result<models::DeleteResponse, Error<DeleteRmFilesystemSystemNameTransferRmDelete0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_account = account;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/rm", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_account {
        req_builder = req_builder.query(&[("account", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRmFilesystemSystemNameTransferRmDelete0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create extract file operation (`tar`) (for files larger than 5242880 Bytes)
pub async fn extract_filesystem_system_name_transfer_extract_post(configuration: &configuration::Configuration, system_name: &str, extract_request: models::ExtractRequest) -> Result<models::ExtractResponse, Error<ExtractFilesystemSystemNameTransferExtractPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_extract_request = extract_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/extract", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_extract_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExtractResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExtractResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExtractFilesystemSystemNameTransferExtractPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create extract file operation (`tar`) (for files larger than 5242880 Bytes)
pub async fn extract_filesystem_system_name_transfer_extract_post_0(configuration: &configuration::Configuration, system_name: &str, extract_request: models::ExtractRequest) -> Result<models::ExtractResponse, Error<ExtractFilesystemSystemNameTransferExtractPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_extract_request = extract_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/extract", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_extract_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExtractResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExtractResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExtractFilesystemSystemNameTransferExtractPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the checksum of a file (using SHA-256 algotithm)
pub async fn get_checksum_filesystem_system_name_ops_checksum_get(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<models::GetFileChecksumResponse, Error<GetChecksumFilesystemSystemNameOpsChecksumGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/checksum", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileChecksumResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileChecksumResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetChecksumFilesystemSystemNameOpsChecksumGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the checksum of a file (using SHA-256 algotithm)
pub async fn get_checksum_filesystem_system_name_ops_checksum_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<models::GetFileChecksumResponse, Error<GetChecksumFilesystemSystemNameOpsChecksumGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/checksum", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileChecksumResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileChecksumResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetChecksumFilesystemSystemNameOpsChecksumGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download a small file (max 5242880 Bytes)
pub async fn get_download_filesystem_system_name_ops_download_get(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<serde_json::Value, Error<GetDownloadFilesystemSystemNameOpsDownloadGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/download", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDownloadFilesystemSystemNameOpsDownloadGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download a small file (max 5242880 Bytes)
pub async fn get_download_filesystem_system_name_ops_download_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<serde_json::Value, Error<GetDownloadFilesystemSystemNameOpsDownloadGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/download", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDownloadFilesystemSystemNameOpsDownloadGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the type of a file or directory
pub async fn get_file_filesystem_system_name_ops_file_get(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<models::GetFileTypeResponse, Error<GetFileFilesystemSystemNameOpsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/file", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileFilesystemSystemNameOpsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the type of a file or directory
pub async fn get_file_filesystem_system_name_ops_file_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str) -> Result<models::GetFileTypeResponse, Error<GetFileFilesystemSystemNameOpsFileGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;

    let uri_str = format!("{}/filesystem/{system_name}/ops/file", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileTypeResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileTypeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileFilesystemSystemNameOpsFileGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the first part of file/s (`head`)
pub async fn get_head_filesystem_system_name_ops_head_get(configuration: &configuration::Configuration, system_name: &str, path: &str, bytes: Option<i32>, lines: Option<i32>, skip_trailing: Option<bool>) -> Result<models::GetFileHeadResponse, Error<GetHeadFilesystemSystemNameOpsHeadGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_bytes = bytes;
    let p_query_lines = lines;
    let p_query_skip_trailing = skip_trailing;

    let uri_str = format!("{}/filesystem/{system_name}/ops/head", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_bytes {
        req_builder = req_builder.query(&[("bytes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_lines {
        req_builder = req_builder.query(&[("lines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip_trailing {
        req_builder = req_builder.query(&[("skipTrailing", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileHeadResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileHeadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHeadFilesystemSystemNameOpsHeadGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the first part of file/s (`head`)
pub async fn get_head_filesystem_system_name_ops_head_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str, bytes: Option<i32>, lines: Option<i32>, skip_trailing: Option<bool>) -> Result<models::GetFileHeadResponse, Error<GetHeadFilesystemSystemNameOpsHeadGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_bytes = bytes;
    let p_query_lines = lines;
    let p_query_skip_trailing = skip_trailing;

    let uri_str = format!("{}/filesystem/{system_name}/ops/head", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_bytes {
        req_builder = req_builder.query(&[("bytes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_lines {
        req_builder = req_builder.query(&[("lines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip_trailing {
        req_builder = req_builder.query(&[("skipTrailing", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileHeadResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileHeadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHeadFilesystemSystemNameOpsHeadGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the contents of the given directory (`ls`)
pub async fn get_ls_filesystem_system_name_ops_ls_get(configuration: &configuration::Configuration, system_name: &str, path: &str, show_hidden: Option<bool>, numeric_uid: Option<bool>, recursive: Option<bool>, dereference: Option<bool>) -> Result<models::GetDirectoryLsResponse, Error<GetLsFilesystemSystemNameOpsLsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_show_hidden = show_hidden;
    let p_query_numeric_uid = numeric_uid;
    let p_query_recursive = recursive;
    let p_query_dereference = dereference;

    let uri_str = format!("{}/filesystem/{system_name}/ops/ls", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_show_hidden {
        req_builder = req_builder.query(&[("showHidden", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numeric_uid {
        req_builder = req_builder.query(&[("numericUid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dereference {
        req_builder = req_builder.query(&[("dereference", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDirectoryLsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDirectoryLsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLsFilesystemSystemNameOpsLsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the contents of the given directory (`ls`)
pub async fn get_ls_filesystem_system_name_ops_ls_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str, show_hidden: Option<bool>, numeric_uid: Option<bool>, recursive: Option<bool>, dereference: Option<bool>) -> Result<models::GetDirectoryLsResponse, Error<GetLsFilesystemSystemNameOpsLsGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_show_hidden = show_hidden;
    let p_query_numeric_uid = numeric_uid;
    let p_query_recursive = recursive;
    let p_query_dereference = dereference;

    let uri_str = format!("{}/filesystem/{system_name}/ops/ls", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_show_hidden {
        req_builder = req_builder.query(&[("showHidden", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_numeric_uid {
        req_builder = req_builder.query(&[("numericUid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dereference {
        req_builder = req_builder.query(&[("dereference", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetDirectoryLsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetDirectoryLsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLsFilesystemSystemNameOpsLsGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the `stat` of a file
pub async fn get_stat_filesystem_system_name_ops_stat_get(configuration: &configuration::Configuration, system_name: &str, path: &str, dereference: Option<bool>) -> Result<models::GetFileStatResponse, Error<GetStatFilesystemSystemNameOpsStatGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_dereference = dereference;

    let uri_str = format!("{}/filesystem/{system_name}/ops/stat", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_dereference {
        req_builder = req_builder.query(&[("dereference", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileStatResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileStatResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStatFilesystemSystemNameOpsStatGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the `stat` of a file
pub async fn get_stat_filesystem_system_name_ops_stat_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str, dereference: Option<bool>) -> Result<models::GetFileStatResponse, Error<GetStatFilesystemSystemNameOpsStatGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_dereference = dereference;

    let uri_str = format!("{}/filesystem/{system_name}/ops/stat", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_dereference {
        req_builder = req_builder.query(&[("dereference", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileStatResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileStatResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStatFilesystemSystemNameOpsStatGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the last part of a file (`tail`)
pub async fn get_tail_filesystem_system_name_ops_tail_get(configuration: &configuration::Configuration, system_name: &str, path: &str, bytes: Option<i32>, lines: Option<i32>, skip_heading: Option<bool>) -> Result<models::GetFileTailResponse, Error<GetTailFilesystemSystemNameOpsTailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_bytes = bytes;
    let p_query_lines = lines;
    let p_query_skip_heading = skip_heading;

    let uri_str = format!("{}/filesystem/{system_name}/ops/tail", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_bytes {
        req_builder = req_builder.query(&[("bytes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_lines {
        req_builder = req_builder.query(&[("lines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip_heading {
        req_builder = req_builder.query(&[("skipHeading", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileTailResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileTailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTailFilesystemSystemNameOpsTailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Output the last part of a file (`tail`)
pub async fn get_tail_filesystem_system_name_ops_tail_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str, bytes: Option<i32>, lines: Option<i32>, skip_heading: Option<bool>) -> Result<models::GetFileTailResponse, Error<GetTailFilesystemSystemNameOpsTailGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_bytes = bytes;
    let p_query_lines = lines;
    let p_query_skip_heading = skip_heading;

    let uri_str = format!("{}/filesystem/{system_name}/ops/tail", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_bytes {
        req_builder = req_builder.query(&[("bytes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_lines {
        req_builder = req_builder.query(&[("lines", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_skip_heading {
        req_builder = req_builder.query(&[("skipHeading", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileTailResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileTailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTailFilesystemSystemNameOpsTailGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// View file content (up to max 5242880 bytes)
pub async fn get_view_filesystem_system_name_ops_view_get(configuration: &configuration::Configuration, system_name: &str, path: &str, size: Option<i32>, offset: Option<i32>) -> Result<models::GetViewFileResponse, Error<GetViewFilesystemSystemNameOpsViewGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_size = size;
    let p_query_offset = offset;

    let uri_str = format!("{}/filesystem/{system_name}/ops/view", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetViewFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetViewFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetViewFilesystemSystemNameOpsViewGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// View file content (up to max 5242880 bytes)
pub async fn get_view_filesystem_system_name_ops_view_get_0(configuration: &configuration::Configuration, system_name: &str, path: &str, size: Option<i32>, offset: Option<i32>) -> Result<models::GetViewFileResponse, Error<GetViewFilesystemSystemNameOpsViewGet0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_query_size = size;
    let p_query_offset = offset;

    let uri_str = format!("{}/filesystem/{system_name}/ops/view", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetViewFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetViewFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetViewFilesystemSystemNameOpsViewGet0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create move file or directory operation (`mv`) (for files larger than 5242880 Bytes)
pub async fn move_mv_filesystem_system_name_transfer_mv_post(configuration: &configuration::Configuration, system_name: &str, move_request: models::MoveRequest) -> Result<models::MoveResponse, Error<MoveMvFilesystemSystemNameTransferMvPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_move_request = move_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/mv", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_move_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MoveResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MoveResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveMvFilesystemSystemNameTransferMvPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create move file or directory operation (`mv`) (for files larger than 5242880 Bytes)
pub async fn move_mv_filesystem_system_name_transfer_mv_post_0(configuration: &configuration::Configuration, system_name: &str, move_request: models::MoveRequest) -> Result<models::MoveResponse, Error<MoveMvFilesystemSystemNameTransferMvPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_move_request = move_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/mv", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_move_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MoveResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MoveResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveMvFilesystemSystemNameTransferMvPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Compress files and directories using `tar` command
pub async fn post_compress_filesystem_system_name_ops_compress_post(configuration: &configuration::Configuration, system_name: &str, post_compress_request: models::PostCompressRequest) -> Result<(), Error<PostCompressFilesystemSystemNameOpsCompressPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_compress_request = post_compress_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/compress", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_compress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostCompressFilesystemSystemNameOpsCompressPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Compress files and directories using `tar` command
pub async fn post_compress_filesystem_system_name_ops_compress_post_0(configuration: &configuration::Configuration, system_name: &str, post_compress_request: models::PostCompressRequest) -> Result<(), Error<PostCompressFilesystemSystemNameOpsCompressPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_compress_request = post_compress_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/compress", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_compress_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostCompressFilesystemSystemNameOpsCompressPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create copy file or directory operation (`cp`) (for files larger than 5242880 Bytes)
pub async fn post_cp_filesystem_system_name_transfer_cp_post(configuration: &configuration::Configuration, system_name: &str, copy_request: models::CopyRequest) -> Result<models::CopyResponse, Error<PostCpFilesystemSystemNameTransferCpPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_copy_request = copy_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/cp", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_copy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CopyResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CopyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostCpFilesystemSystemNameTransferCpPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create copy file or directory operation (`cp`) (for files larger than 5242880 Bytes)
pub async fn post_cp_filesystem_system_name_transfer_cp_post_0(configuration: &configuration::Configuration, system_name: &str, copy_request: models::CopyRequest) -> Result<models::CopyResponse, Error<PostCpFilesystemSystemNameTransferCpPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_copy_request = copy_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/cp", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_copy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CopyResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CopyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostCpFilesystemSystemNameTransferCpPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create asynchronous download operation (for files larger than 5242880 Bytes)
pub async fn post_download_filesystem_system_name_transfer_download_post(configuration: &configuration::Configuration, system_name: &str, post_file_download_request: models::PostFileDownloadRequest) -> Result<models::DownloadFileResponse, Error<PostDownloadFilesystemSystemNameTransferDownloadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_download_request = post_file_download_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/download", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_download_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DownloadFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DownloadFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostDownloadFilesystemSystemNameTransferDownloadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create asynchronous download operation (for files larger than 5242880 Bytes)
pub async fn post_download_filesystem_system_name_transfer_download_post_0(configuration: &configuration::Configuration, system_name: &str, post_file_download_request: models::PostFileDownloadRequest) -> Result<models::DownloadFileResponse, Error<PostDownloadFilesystemSystemNameTransferDownloadPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_download_request = post_file_download_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/download", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_download_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DownloadFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DownloadFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostDownloadFilesystemSystemNameTransferDownloadPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Extract `tar` `gzip` archives
pub async fn post_extract_filesystem_system_name_ops_extract_post(configuration: &configuration::Configuration, system_name: &str, post_extract_request: models::PostExtractRequest) -> Result<(), Error<PostExtractFilesystemSystemNameOpsExtractPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_extract_request = post_extract_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/extract", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_extract_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostExtractFilesystemSystemNameOpsExtractPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Extract `tar` `gzip` archives
pub async fn post_extract_filesystem_system_name_ops_extract_post_0(configuration: &configuration::Configuration, system_name: &str, post_extract_request: models::PostExtractRequest) -> Result<(), Error<PostExtractFilesystemSystemNameOpsExtractPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_extract_request = post_extract_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/extract", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_extract_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostExtractFilesystemSystemNameOpsExtractPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create directory operation (`mkdir`)
pub async fn post_mkdir_filesystem_system_name_ops_mkdir_post(configuration: &configuration::Configuration, system_name: &str, post_make_dir_request: models::PostMakeDirRequest) -> Result<models::PostMkdirResponse, Error<PostMkdirFilesystemSystemNameOpsMkdirPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_make_dir_request = post_make_dir_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/mkdir", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_make_dir_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostMkdirResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostMkdirResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostMkdirFilesystemSystemNameOpsMkdirPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create directory operation (`mkdir`)
pub async fn post_mkdir_filesystem_system_name_ops_mkdir_post_0(configuration: &configuration::Configuration, system_name: &str, post_make_dir_request: models::PostMakeDirRequest) -> Result<models::PostMkdirResponse, Error<PostMkdirFilesystemSystemNameOpsMkdirPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_make_dir_request = post_make_dir_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/mkdir", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_make_dir_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostMkdirResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostMkdirResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostMkdirFilesystemSystemNameOpsMkdirPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create symlink operation (`ln`)
pub async fn post_symlink_filesystem_system_name_ops_symlink_post(configuration: &configuration::Configuration, system_name: &str, post_file_symlink_request: models::PostFileSymlinkRequest) -> Result<models::PostFileSymlinkResponse, Error<PostSymlinkFilesystemSystemNameOpsSymlinkPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_symlink_request = post_file_symlink_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/symlink", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_symlink_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostFileSymlinkResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostFileSymlinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostSymlinkFilesystemSystemNameOpsSymlinkPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create symlink operation (`ln`)
pub async fn post_symlink_filesystem_system_name_ops_symlink_post_0(configuration: &configuration::Configuration, system_name: &str, post_file_symlink_request: models::PostFileSymlinkRequest) -> Result<models::PostFileSymlinkResponse, Error<PostSymlinkFilesystemSystemNameOpsSymlinkPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_symlink_request = post_file_symlink_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/symlink", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_symlink_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostFileSymlinkResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostFileSymlinkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostSymlinkFilesystemSystemNameOpsSymlinkPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload a small file (max 5242880 Bytes)
pub async fn post_upload_filesystem_system_name_ops_upload_post(configuration: &configuration::Configuration, system_name: &str, path: &str, file: std::path::PathBuf) -> Result<(), Error<PostUploadFilesystemSystemNameOpsUploadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_form_file = file;

    let uri_str = format!("{}/filesystem/{system_name}/ops/upload", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUploadFilesystemSystemNameOpsUploadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload a small file (max 5242880 Bytes)
pub async fn post_upload_filesystem_system_name_ops_upload_post_0(configuration: &configuration::Configuration, system_name: &str, path: &str, file: std::path::PathBuf) -> Result<(), Error<PostUploadFilesystemSystemNameOpsUploadPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_query_path = path;
    let p_form_file = file;

    let uri_str = format!("{}/filesystem/{system_name}/ops/upload", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUploadFilesystemSystemNameOpsUploadPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create asynchronous upload operation (for files larger than 5242880 Bytes)
pub async fn post_upload_filesystem_system_name_transfer_upload_post(configuration: &configuration::Configuration, system_name: &str, post_file_upload_request: models::PostFileUploadRequest) -> Result<models::UploadFileResponse, Error<PostUploadFilesystemSystemNameTransferUploadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_upload_request = post_file_upload_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/upload", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUploadFilesystemSystemNameTransferUploadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create asynchronous upload operation (for files larger than 5242880 Bytes)
pub async fn post_upload_filesystem_system_name_transfer_upload_post_0(configuration: &configuration::Configuration, system_name: &str, post_file_upload_request: models::PostFileUploadRequest) -> Result<models::UploadFileResponse, Error<PostUploadFilesystemSystemNameTransferUploadPost0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_post_file_upload_request = post_file_upload_request;

    let uri_str = format!("{}/filesystem/{system_name}/transfer/upload", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_file_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadFileResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadFileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUploadFilesystemSystemNameTransferUploadPost0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the permission mode of a file(`chmod`)
pub async fn put_chmod_filesystem_system_name_ops_chmod_put(configuration: &configuration::Configuration, system_name: &str, put_file_chmod_request: models::PutFileChmodRequest) -> Result<models::PutFileChmodResponse, Error<PutChmodFilesystemSystemNameOpsChmodPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_put_file_chmod_request = put_file_chmod_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/chmod", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_put_file_chmod_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PutFileChmodResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PutFileChmodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutChmodFilesystemSystemNameOpsChmodPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the permission mode of a file(`chmod`)
pub async fn put_chmod_filesystem_system_name_ops_chmod_put_0(configuration: &configuration::Configuration, system_name: &str, put_file_chmod_request: models::PutFileChmodRequest) -> Result<models::PutFileChmodResponse, Error<PutChmodFilesystemSystemNameOpsChmodPut0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_put_file_chmod_request = put_file_chmod_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/chmod", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_put_file_chmod_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PutFileChmodResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PutFileChmodResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutChmodFilesystemSystemNameOpsChmodPut0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the ownership of a given file (`chown`)
pub async fn put_chown_filesystem_system_name_ops_chown_put(configuration: &configuration::Configuration, system_name: &str, put_file_chown_request: models::PutFileChownRequest) -> Result<models::PutFileChownResponse, Error<PutChownFilesystemSystemNameOpsChownPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_put_file_chown_request = put_file_chown_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/chown", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_put_file_chown_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PutFileChownResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PutFileChownResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutChownFilesystemSystemNameOpsChownPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the ownership of a given file (`chown`)
pub async fn put_chown_filesystem_system_name_ops_chown_put_0(configuration: &configuration::Configuration, system_name: &str, put_file_chown_request: models::PutFileChownRequest) -> Result<models::PutFileChownResponse, Error<PutChownFilesystemSystemNameOpsChownPut0Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_system_name = system_name;
    let p_body_put_file_chown_request = put_file_chown_request;

    let uri_str = format!("{}/filesystem/{system_name}/ops/chown", configuration.base_path, system_name=crate::apis::urlencode(p_path_system_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_put_file_chown_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PutFileChownResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PutFileChownResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutChownFilesystemSystemNameOpsChownPut0Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}


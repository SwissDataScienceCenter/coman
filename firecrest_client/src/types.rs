// @generated by oas3-gen
#![allow(clippy::all)]
#![allow(dead_code)]
#![allow(clippy::doc_markdown)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::missing_panics_doc)]
#![allow(clippy::result_large_err)]
//!
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! FirecREST
//! Source: /tmp/.tmpHQC8ft.json
//! Version: 2.4.1
//! Generated by `oas3-gen v0.21.1`
//!
//! No description provided

use serde::{Deserialize, Serialize};
static REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID: std::sync::LazyLock<regex::Regex> =
    std::sync::LazyLock::new(|| regex::Regex::new("^[a-zA-Z0-9]+$").expect("invalid regex"));
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ApResponseErrorType {
    #[serde(rename = "error")]
    #[default]
    Error,
    #[serde(rename = "validation")]
    Validation,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ApiResponseError {
    pub data: Option<serde_json::Value>,
    #[serde(rename = "errorType")]
    pub error_type: Option<String>,
    pub message: String,
    pub user: Option<String>,
}
impl std::fmt::Display for ApiResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}
impl std::error::Error for ApiResponseError {}
///Attach a procces to a job by `{job_id}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct AttachComputeSystemNameJobsJobIdAttachPutRequest {
    ///Job id
    /// - Location: `Path`
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: AttachComputeSystemNameJobsJobIdAttachPutRequestBody,
}
impl AttachComputeSystemNameJobsJobIdAttachPutRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "compute/{}/jobs/{}/attach",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?),
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.job_id)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
pub type AttachComputeSystemNameJobsJobIdAttachPutRequestBody = PostJobAttachRequest;
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct BodyPostUploadFilesystemSystemNameOpsUploadPost {
    ///File to be uploaded as `multipart/form-data`
    pub file: Vec<u8>,
}
///Configuration for automatic object lifecycle in storage buckets.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct BucketLifecycleConfiguration {
    ///Number of days after which objects will expire automatically.
    #[default(Some(10i64))]
    pub days: Option<i64>,
}
///Create compress file or directory operation (`tar`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct CompressFilesystemSystemNameTransferCompressPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: CompressFilesystemSystemNameTransferCompressPostRequestBody,
}
impl CompressFilesystemSystemNameTransferCompressPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/compress",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<CompressFilesystemSystemNameTransferCompressPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<CompressResponse>::json_with_diagnostics(req).await?;
            return Ok(CompressFilesystemSystemNameTransferCompressPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(CompressFilesystemSystemNameTransferCompressPostResponse::ClientError(
                data,
            ));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(CompressFilesystemSystemNameTransferCompressPostResponse::ServerError(
                data,
            ));
        }
        let _ = req.bytes().await?;
        Ok(CompressFilesystemSystemNameTransferCompressPostResponse::Unknown)
    }
}
pub type CompressFilesystemSystemNameTransferCompressPostRequestBody = CompressRequest;
///Response types for compress_filesystem__system_name__transfer_compress_post
#[derive(Clone, Debug)]
pub enum CompressFilesystemSystemNameTransferCompressPostResponse {
    ///201: Compress file or directory operation created successfully
    Created(CompressResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CompressRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some(Default::default()))]
    pub compression: Option<CompressionType>,
    ///If set to `true`, it follows symbolic links and archive the files they point to instead of the links
    /// themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    ///Regex pattern to filter files to compress
    #[serde(rename = "matchPattern")]
    pub match_pattern: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the compress operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct CompressResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, oas3_gen_support::Default)]
pub enum CompressionType {
    #[serde(rename = "none")]
    #[default]
    None,
    #[serde(rename = "bzip2")]
    Bzip2,
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "xz")]
    Xz,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ContentUnit {
    #[serde(rename = "lines")]
    #[default]
    Lines,
    #[serde(rename = "bytes")]
    Bytes,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CopyRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///If set to `true`, it follows symbolic links and copies the files they point to instead of the links themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the copy operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct CopyResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct DataOperation {
    ///Data transfer service configuration
    pub data_transfer: Option<S3DataTransfer>,
    ///Maximum file size (in bytes) allowed for direct upload and download. Larger files will go through the staging
    /// area.
    #[default(Some(5242880i64))]
    pub max_ops_file_size: Option<i64>,
}
///Cancel a job
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteJobCancelComputeSystemNameJobsJobIdDeleteRequest {
    ///Job id
    /// - Location: `Path`
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl DeleteJobCancelComputeSystemNameJobsJobIdDeleteRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "compute/{}/jobs/{}",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?),
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.job_id)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct DeleteResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Delete file or directory operation (`rm`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteRmFilesystemSystemNameOpsRmDeleteRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///The path to delete
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
}
impl DeleteRmFilesystemSystemNameOpsRmDeleteRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/rm",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
///Response types for delete_rm_filesystem__system_name__ops_rm_delete
#[derive(Clone, Debug)]
pub enum DeleteRmFilesystemSystemNameOpsRmDeleteResponse {
    ///204: File or directory deleted successfully
    NoContent,
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Create remove file or directory operation (`rm`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteRmFilesystemSystemNameTransferRmDeleteRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///The path to delete
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    /// - Location: `Query`
    pub account: Option<String>,
}
impl DeleteRmFilesystemSystemNameTransferRmDeleteRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/transfer/rm",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.account {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}account={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameTransferRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<DeleteResponse>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameTransferRmDeleteResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameTransferRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameTransferRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameTransferRmDeleteResponse::Unknown)
    }
}
///Response types for delete_rm_filesystem__system_name__transfer_rm_delete
#[derive(Clone, Debug)]
pub enum DeleteRmFilesystemSystemNameTransferRmDeleteResponse {
    ///200: Remove file or directory operation created successfully
    Ok(DeleteResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct DownloadFileResponse {
    ///Data transfer parameters specific to the transfer method
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: DownloadFileResponseTransferDirectives,
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Data transfer parameters specific to the transfer method
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum DownloadFileResponseTransferDirectives {
    #[default]
    Wormhole(WormholeTransferResponse),
    S3(S3TransferResponse),
    Streamer(StreamerTransferResponse),
}
impl DownloadFileResponseTransferDirectives {
    ///Creates a `Wormhole` variant with default values.
    pub fn wormhole() -> Self {
        Self::Wormhole(WormholeTransferResponse::default())
    }
    ///Creates a `S3` variant with default values.
    pub fn s3() -> Self {
        Self::S3(S3TransferResponse::default())
    }
    ///Creates a `Streamer` variant with default values.
    pub fn streamer() -> Self {
        Self::Streamer(StreamerTransferResponse::default())
    }
}
///Create extract file operation (`tar`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct ExtractFilesystemSystemNameTransferExtractPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: ExtractFilesystemSystemNameTransferExtractPostRequestBody,
}
impl ExtractFilesystemSystemNameTransferExtractPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/extract",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<ExtractFilesystemSystemNameTransferExtractPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<ExtractResponse>::json_with_diagnostics(req).await?;
            return Ok(ExtractFilesystemSystemNameTransferExtractPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(ExtractFilesystemSystemNameTransferExtractPostResponse::ClientError(
                data,
            ));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(ExtractFilesystemSystemNameTransferExtractPostResponse::ServerError(
                data,
            ));
        }
        let _ = req.bytes().await?;
        Ok(ExtractFilesystemSystemNameTransferExtractPostResponse::Unknown)
    }
}
pub type ExtractFilesystemSystemNameTransferExtractPostRequestBody = ExtractRequest;
///Response types for extract_filesystem__system_name__transfer_extract_post
#[derive(Clone, Debug)]
pub enum ExtractFilesystemSystemNameTransferExtractPostResponse {
    ///201: Extract file or directory operation created successfully
    Created(ExtractResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct ExtractRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some(Default::default()))]
    pub compression: Option<CompressionType>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the directory where to extract the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ExtractResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct File {
    pub group: String,
    #[serde(rename = "lastModified")]
    pub last_modified: String,
    #[serde(rename = "linkTarget")]
    pub link_target: Option<String>,
    pub name: String,
    pub permissions: String,
    pub size: String,
    #[serde(rename = "type")]
    pub r#type: String,
    pub user: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct FileChecksum {
    #[default(Some("SHA-256".to_string()))]
    pub algorithm: Option<String>,
    pub checksum: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FileContent {
    pub content: String,
    #[serde(rename = "contentType")]
    pub content_type: String,
    #[serde(rename = "endPosition")]
    pub end_position: i64,
    #[serde(rename = "startPosition")]
    pub start_position: i64,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FileStat {
    pub atime: i64,
    pub ctime: i64,
    pub dev: i64,
    pub gid: i64,
    pub ino: i64,
    pub mode: i64,
    pub mtime: i64,
    pub nlink: i64,
    pub size: i64,
    pub uid: i64,
}
///Defines a cluster file system and its type.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct FileSystem {
    ///Data types for cluster file systems.
    #[serde(rename = "dataType")]
    pub data_type: String,
    ///Mark this as the default working directory.
    #[serde(rename = "defaultWorkDir")]
    #[default(Some(false))]
    pub default_work_dir: Option<bool>,
    ///Mount path for the file system.
    pub path: String,
}
///Data types for cluster file systems.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum FileSystemDataType {
    #[serde(rename = "users")]
    #[default]
    Users,
    #[serde(rename = "store")]
    Store,
    #[serde(rename = "archive")]
    Archive,
    #[serde(rename = "apps")]
    Apps,
    #[serde(rename = "scratch")]
    Scratch,
    #[serde(rename = "project")]
    Project,
}
///Health check for a mounted file system.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct FilesystemServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Path of the monitored file system.
    pub path: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FirecrestFilesystemTransferModelsTransferJob {
    #[serde(rename = "jobId")]
    pub job_id: i64,
    pub logs: FirecrestFilesystemTransferModelsTransferJobLogs,
    pub system: String,
    #[serde(rename = "workingDirectory")]
    pub working_directory: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct FirecrestFilesystemTransferModelsTransferJobLogs {
    #[serde(rename = "errorLog")]
    pub error_log: String,
    #[serde(rename = "outputLog")]
    pub output_log: String,
}
///Output the checksum of a file (using SHA-256 algotithm)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetChecksumFilesystemSystemNameOpsChecksumGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///Target system
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
}
impl GetChecksumFilesystemSystemNameOpsChecksumGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/checksum",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetChecksumFilesystemSystemNameOpsChecksumGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetFileChecksumResponse>::json_with_diagnostics(req).await?;
            return Ok(GetChecksumFilesystemSystemNameOpsChecksumGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetChecksumFilesystemSystemNameOpsChecksumGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetChecksumFilesystemSystemNameOpsChecksumGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetChecksumFilesystemSystemNameOpsChecksumGetResponse::Unknown)
    }
}
///Response types for get_checksum_filesystem__system_name__ops_checksum_get
#[derive(Clone, Debug)]
pub enum GetChecksumFilesystemSystemNameOpsChecksumGetResponse {
    ///200: Checksum returned successfully
    Ok(GetFileChecksumResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetDirectoryLsResponse {
    pub output: Option<Vec<File>>,
}
///Download a small file (max 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetDownloadFilesystemSystemNameOpsDownloadGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///A file to download
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
}
impl GetDownloadFilesystemSystemNameOpsDownloadGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/download",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetDownloadFilesystemSystemNameOpsDownloadGetResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(GetDownloadFilesystemSystemNameOpsDownloadGetResponse::Ok);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetDownloadFilesystemSystemNameOpsDownloadGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetDownloadFilesystemSystemNameOpsDownloadGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetDownloadFilesystemSystemNameOpsDownloadGetResponse::Unknown)
    }
}
///Response types for get_download_filesystem__system_name__ops_download_get
#[derive(Clone, Debug)]
pub enum GetDownloadFilesystemSystemNameOpsDownloadGetResponse {
    ///200: File downloaded successfully
    Ok,
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetFileChecksumResponse {
    pub output: Option<FileChecksum>,
}
///Output the type of a file or directory
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileFilesystemSystemNameOpsFileGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///A file or folder path
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
}
impl GetFileFilesystemSystemNameOpsFileGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/file",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetFileFilesystemSystemNameOpsFileGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetFileTypeResponse>::json_with_diagnostics(req).await?;
            return Ok(GetFileFilesystemSystemNameOpsFileGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetFileFilesystemSystemNameOpsFileGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetFileFilesystemSystemNameOpsFileGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetFileFilesystemSystemNameOpsFileGetResponse::Unknown)
    }
}
///Response types for get_file_filesystem__system_name__ops_file_get
#[derive(Clone, Debug)]
pub enum GetFileFilesystemSystemNameOpsFileGetResponse {
    ///200: Type returned successfully
    Ok(GetFileTypeResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetFileHeadResponse {
    pub output: Option<FileContent>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetFileStatResponse {
    pub output: Option<FileStat>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetFileTailResponse {
    pub output: Option<FileContent>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetFileTypeResponse {
    pub output: Option<String>,
}
///Output the first part of file/s (`head`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetHeadFilesystemSystemNameOpsHeadGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///File path
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    ///The output will be the first NUM bytes of each file.
    /// - Location: `Query`
    pub bytes: Option<i64>,
    ///The output will be the first NUM lines of each file.
    /// - Location: `Query`
    pub lines: Option<i64>,
    ///The output will be the whole file, without the last NUM bytes/lines of each file. NUM should be specified in
    /// the respective argument through `bytes` or `lines`.
    /// - Location: `Query`
    #[default(Some(false))]
    pub skip_trailing: Option<bool>,
}
impl GetHeadFilesystemSystemNameOpsHeadGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/head",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.bytes {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}bytes={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.lines {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}lines={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.skip_trailing {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}skipTrailing={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetHeadFilesystemSystemNameOpsHeadGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetFileHeadResponse>::json_with_diagnostics(req).await?;
            return Ok(GetHeadFilesystemSystemNameOpsHeadGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetHeadFilesystemSystemNameOpsHeadGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetHeadFilesystemSystemNameOpsHeadGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetHeadFilesystemSystemNameOpsHeadGetResponse::Unknown)
    }
}
///Response types for get_head_filesystem__system_name__ops_head_get
#[derive(Clone, Debug)]
pub enum GetHeadFilesystemSystemNameOpsHeadGetResponse {
    ///200: Head operation finished successfully
    Ok(GetFileHeadResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Get status of a job by `{job_id}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobComputeSystemNameJobsJobIdGetRequest {
    ///Job id
    /// - Location: `Path`
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetJobComputeSystemNameJobsJobIdGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "compute/{}/jobs/{}",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?),
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.job_id)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetJobsComputeSystemNameJobsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetJobResponse>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetJobsComputeSystemNameJobsGetResponse::Unknown)
    }
}
///Get metadata of a job by `{job_id}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobMetadataComputeSystemNameJobsJobIdMetadataGetRequest {
    ///Job id
    /// - Location: `Path`
    #[validate(
        length(min = 1u64),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetJobMetadataComputeSystemNameJobsJobIdMetadataGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "compute/{}/jobs/{}/metadata",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?),
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.job_id)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetJobMetadataResponse>::json_with_diagnostics(req).await?;
            return Ok(GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse::Unknown)
    }
}
///Response types for get_job_metadata_compute__system_name__jobs__job_id__metadata_get
#[derive(Clone, Debug)]
pub enum GetJobMetadataComputeSystemNameJobsJobIdMetadataGetResponse {
    ///200: Jobs metadata returned successfully
    Ok(GetJobMetadataResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetJobMetadataResponse {
    pub jobs: Option<Vec<JobMetadataModel>>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetJobResponse {
    pub jobs: Option<Vec<JobModel>>,
}
///Get status of all jobs
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobsComputeSystemNameJobsGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///If set to `true` returns all jobs visible by the current user, otherwise only the current user owned jobs
    /// - Location: `Query`
    #[default(Some(false))]
    pub allusers: Option<bool>,
}
impl GetJobsComputeSystemNameJobsGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "compute/{}/jobs",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        if let Some(value) = &self.allusers {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}allusers={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetJobsComputeSystemNameJobsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetJobResponse>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetJobsComputeSystemNameJobsGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetJobsComputeSystemNameJobsGetResponse::Unknown)
    }
}
///Response types for get_jobs_compute__system_name__jobs_get
#[derive(Clone, Debug)]
pub enum GetJobsComputeSystemNameJobsGetResponse {
    ///200: Jobs status returned successfully
    Ok(GetJobResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetLiveness {
    #[serde(rename = "healthcheckRuns")]
    pub healthcheck_runs: Option<serde_json::Value>,
    #[serde(rename = "lastUpdate")]
    pub last_update: Option<i64>,
}
///Get liveness status of FirecREST
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetLivenessStatusLivenessGetRequest {}
impl GetLivenessStatusLivenessGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok("status/liveness/".to_string())
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetLivenessStatusLivenessGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetLiveness>::json_with_diagnostics(req).await?;
            return Ok(GetLivenessStatusLivenessGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetLivenessStatusLivenessGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetLivenessStatusLivenessGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetLivenessStatusLivenessGetResponse::Unknown)
    }
}
///Response types for get_liveness_status_liveness__get
#[derive(Clone, Debug)]
pub enum GetLivenessStatusLivenessGetResponse {
    ///200: Liveness status returned successfully
    Ok(GetLiveness),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///List the contents of the given directory (`ls`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetLsFilesystemSystemNameOpsLsGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///The path to list
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    ///Show hidden files
    /// - Location: `Query`
    #[default(Some(false))]
    pub show_hidden: Option<bool>,
    ///List numeric user and group IDs
    /// - Location: `Query`
    #[default(Some(false))]
    pub numeric_uid: Option<bool>,
    ///Recursively list files and folders
    /// - Location: `Query`
    #[default(Some(false))]
    pub recursive: Option<bool>,
    ///Show information for the file the link references.
    /// - Location: `Query`
    #[default(Some(false))]
    pub dereference: Option<bool>,
}
impl GetLsFilesystemSystemNameOpsLsGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/ls",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.show_hidden {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}showHidden={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.numeric_uid {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}numericUid={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.recursive {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}recursive={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.dereference {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}dereference={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetLsFilesystemSystemNameOpsLsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetDirectoryLsResponse>::json_with_diagnostics(req).await?;
            return Ok(GetLsFilesystemSystemNameOpsLsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetLsFilesystemSystemNameOpsLsGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetLsFilesystemSystemNameOpsLsGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetLsFilesystemSystemNameOpsLsGetResponse::Unknown)
    }
}
///Response types for get_ls_filesystem__system_name__ops_ls_get
#[derive(Clone, Debug)]
pub enum GetLsFilesystemSystemNameOpsLsGetResponse {
    ///200: Directory listed successfully
    Ok(GetDirectoryLsResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetNodesResponse {
    pub nodes: Vec<NodeModel>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetPartitionsResponse {
    pub partitions: Vec<PartitionModel>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetReservationsResponse {
    pub reservations: Vec<ReservationModel>,
}
///Output the `stat` of a file
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetStatFilesystemSystemNameOpsStatGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///A file or folder path
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    ///Follow symbolic links
    /// - Location: `Query`
    #[default(Some(false))]
    pub dereference: Option<bool>,
}
impl GetStatFilesystemSystemNameOpsStatGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/stat",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.dereference {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}dereference={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetStatFilesystemSystemNameOpsStatGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetFileStatResponse>::json_with_diagnostics(req).await?;
            return Ok(GetStatFilesystemSystemNameOpsStatGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetStatFilesystemSystemNameOpsStatGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetStatFilesystemSystemNameOpsStatGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetStatFilesystemSystemNameOpsStatGetResponse::Unknown)
    }
}
///Response types for get_stat_filesystem__system_name__ops_stat_get
#[derive(Clone, Debug)]
pub enum GetStatFilesystemSystemNameOpsStatGetResponse {
    ///200: Stat returned successfully
    Ok(GetFileStatResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Get the list of nodes of a `{system_name}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemNodesStatusSystemNameNodesGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetSystemNodesStatusSystemNameNodesGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "status/{}/nodes",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetSystemNodesStatusSystemNameNodesGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetNodesResponse>::json_with_diagnostics(req).await?;
            return Ok(GetSystemNodesStatusSystemNameNodesGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemNodesStatusSystemNameNodesGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemNodesStatusSystemNameNodesGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetSystemNodesStatusSystemNameNodesGetResponse::Unknown)
    }
}
///Response types for get_system_nodes_status__system_name__nodes_get
#[derive(Clone, Debug)]
pub enum GetSystemNodesStatusSystemNameNodesGetResponse {
    ///200: Nodes list returned successfully
    Ok(GetNodesResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Get the list of partitions of a `{system_name}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemPartitionsStatusSystemNamePartitionsGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetSystemPartitionsStatusSystemNamePartitionsGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "status/{}/partitions",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetSystemPartitionsStatusSystemNamePartitionsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetPartitionsResponse>::json_with_diagnostics(req).await?;
            return Ok(GetSystemPartitionsStatusSystemNamePartitionsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemPartitionsStatusSystemNamePartitionsGetResponse::ClientError(
                data,
            ));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemPartitionsStatusSystemNamePartitionsGetResponse::ServerError(
                data,
            ));
        }
        let _ = req.bytes().await?;
        Ok(GetSystemPartitionsStatusSystemNamePartitionsGetResponse::Unknown)
    }
}
///Response types for get_system_partitions_status__system_name__partitions_get
#[derive(Clone, Debug)]
pub enum GetSystemPartitionsStatusSystemNamePartitionsGetResponse {
    ///200: Partitions list returned successfully
    Ok(GetPartitionsResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Get the list of reservations of a `{system_name}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemReservationsStatusSystemNameReservationsGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetSystemReservationsStatusSystemNameReservationsGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "status/{}/reservations",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetSystemReservationsStatusSystemNameReservationsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetReservationsResponse>::json_with_diagnostics(req).await?;
            return Ok(GetSystemReservationsStatusSystemNameReservationsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemReservationsStatusSystemNameReservationsGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemReservationsStatusSystemNameReservationsGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetSystemReservationsStatusSystemNameReservationsGetResponse::Unknown)
    }
}
///Response types for get_system_reservations_status__system_name__reservations_get
#[derive(Clone, Debug)]
pub enum GetSystemReservationsStatusSystemNameReservationsGetResponse {
    ///200: Reservations list returned successfully
    Ok(GetReservationsResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetSystemsResponse {
    #[serde(rename = "dataOperation")]
    pub data_operation: Option<DataOperation>,
    pub systems: Vec<HPCCluster>,
}
///Get the list of systems and health status
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemsStatusSystemsGetRequest {}
impl GetSystemsStatusSystemsGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok("status/systems".to_string())
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(req: reqwest::Response) -> anyhow::Result<GetSystemsStatusSystemsGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetSystemsResponse>::json_with_diagnostics(req).await?;
            return Ok(GetSystemsStatusSystemsGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemsStatusSystemsGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetSystemsStatusSystemsGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetSystemsStatusSystemsGetResponse::Unknown)
    }
}
///Response types for get_systems_status_systems_get
#[derive(Clone, Debug)]
pub enum GetSystemsStatusSystemsGetResponse {
    ///200: System list returned successfully
    Ok(GetSystemsResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Output the last part of a file (`tail`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetTailFilesystemSystemNameOpsTailGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///File path
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    ///The output will be the last NUM bytes of each file.
    /// - Location: `Query`
    pub bytes: Option<i64>,
    ///The output will be the last NUM lines of each file.
    /// - Location: `Query`
    pub lines: Option<i64>,
    ///The output will be the whole file, without the first NUM bytes/lines of each file. NUM should be specified in
    /// the respective argument through `bytes` or `lines`.
    /// - Location: `Query`
    #[default(Some(false))]
    pub skip_heading: Option<bool>,
}
impl GetTailFilesystemSystemNameOpsTailGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/tail",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.bytes {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}bytes={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.lines {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}lines={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.skip_heading {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}skipHeading={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetTailFilesystemSystemNameOpsTailGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetFileTailResponse>::json_with_diagnostics(req).await?;
            return Ok(GetTailFilesystemSystemNameOpsTailGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetTailFilesystemSystemNameOpsTailGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetTailFilesystemSystemNameOpsTailGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetTailFilesystemSystemNameOpsTailGetResponse::Unknown)
    }
}
///Response types for get_tail_filesystem__system_name__ops_tail_get
#[derive(Clone, Debug)]
pub enum GetTailFilesystemSystemNameOpsTailGetResponse {
    ///200: `tail` operation finished successfully
    Ok(GetFileTailResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Get current user information on a `{system_name}`
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetUserinfoStatusSystemNameUserinfoGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
}
impl GetUserinfoStatusSystemNameUserinfoGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "status/{}/userinfo",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetUserinfoStatusSystemNameUserinfoGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<UserInfoResponse>::json_with_diagnostics(req).await?;
            return Ok(GetUserinfoStatusSystemNameUserinfoGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetUserinfoStatusSystemNameUserinfoGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetUserinfoStatusSystemNameUserinfoGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetUserinfoStatusSystemNameUserinfoGetResponse::Unknown)
    }
}
///Response types for get_userinfo_status__system_name__userinfo_get
#[derive(Clone, Debug)]
pub enum GetUserinfoStatusSystemNameUserinfoGetResponse {
    ///200: User information returned successfully
    Ok(UserInfoResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct GetViewFileResponse {
    pub output: Option<String>,
}
///View file content (up to max 5242880 bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct GetViewFilesystemSystemNameOpsViewGetRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///File path
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    ///Value, in bytes, of the size of data to be retrieved from the file.
    /// - Location: `Query`
    #[default(Some(5242880i64))]
    pub size: Option<i64>,
    ///Value in bytes of the offset.
    /// - Location: `Query`
    #[default(Some(0i64))]
    pub offset: Option<i64>,
}
impl GetViewFilesystemSystemNameOpsViewGetRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/view",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        if let Some(value) = &self.size {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}size={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        if let Some(value) = &self.offset {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}offset={}",
                oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(value)?)
            )
            .unwrap();
        }
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<GetViewFilesystemSystemNameOpsViewGetResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<GetViewFileResponse>::json_with_diagnostics(req).await?;
            return Ok(GetViewFilesystemSystemNameOpsViewGetResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetViewFilesystemSystemNameOpsViewGetResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(GetViewFilesystemSystemNameOpsViewGetResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(GetViewFilesystemSystemNameOpsViewGetResponse::Unknown)
    }
}
///Response types for get_view_filesystem__system_name__ops_view_get
#[derive(Clone, Debug)]
pub enum GetViewFilesystemSystemNameOpsViewGetResponse {
    ///200: View operation finished successfully
    Ok(GetViewFileResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Definition of an HPC cluster, including SSH access, scheduling, and
///filesystem layout. More info in
///[the systems' section](../arch/systems//README.md).
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct HPCCluster {
    ///Custom scheduler flags passed to data transfer jobs (e.g. `-pxfer` for a dedicated partition).
    #[serde(rename = "datatransferJobsDirectives")]
    pub datatransfer_jobs_directives: Option<Vec<String>>,
    ///List of mounted file systems on the cluster, such as scratch or home directories.
    #[serde(rename = "fileSystems")]
    pub file_systems: Option<Vec<FileSystem>>,
    ///Unique name for the cluster. This field is case insensitive.
    pub name: String,
    ///Probing configuration for monitoring the cluster.
    pub probing: Option<Probing>,
    ///Cluster job scheduler configuration.
    pub scheduler: Scheduler,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<SchedulerServiceHealth>>,
    ///SSH connection pool configuration for remote execution.
    pub ssh: SSHClientPool,
}
///Generic health check error placeholder.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct HealthCheckException {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: String,
}
///Types of services that can be health-checked.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum HealthCheckType {
    #[serde(rename = "scheduler")]
    #[default]
    Scheduler,
    #[serde(rename = "filesystem")]
    Filesystem,
    #[serde(rename = "ssh")]
    Ssh,
    #[serde(rename = "s3")]
    S3,
    #[serde(rename = "exception")]
    Exception,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct JobDescriptionModel {
    ///Charge job resources to specified account
    pub account: Option<String>,
    ///Job constraints
    pub constraints: Option<String>,
    ///Dictionary of environment variables to set in the job context
    #[default(Some(Default::default()))]
    pub env: Option<JobDescriptionModelEnv>,
    ///Name for the job
    pub name: Option<String>,
    ///Script for the job
    pub script: Option<String>,
    ///Path to the job in target system
    #[serde(rename = "scriptPath")]
    pub script_path: Option<String>,
    ///Standard error file name
    #[serde(rename = "standardError")]
    pub standard_error: Option<String>,
    ///Standard input file name
    #[serde(rename = "standardInput")]
    pub standard_input: Option<String>,
    ///Standard output file name
    #[serde(rename = "standardOutput")]
    pub standard_output: Option<String>,
    ///Job working directory
    #[serde(rename = "workingDirectory")]
    #[validate(length(min = 1u64))]
    pub working_directory: String,
}
///Dictionary of environment variables to set in the job context
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum JobDescriptionModelEnv {
    #[default]
    Object(serde_json::Value),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct JobMetadataModel {
    #[serde(rename = "jobId")]
    pub job_id: String,
    pub script: Option<String>,
    #[serde(rename = "standardError")]
    pub standard_error: Option<String>,
    #[serde(rename = "standardInput")]
    pub standard_input: Option<String>,
    #[serde(rename = "standardOutput")]
    pub standard_output: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct JobModel {
    pub account: Option<String>,
    #[serde(rename = "allocationNodes")]
    pub allocation_nodes: i64,
    pub cluster: String,
    pub group: Option<String>,
    #[serde(rename = "jobId")]
    pub job_id: i64,
    #[serde(rename = "killRequestUser")]
    pub kill_request_user: Option<String>,
    pub name: String,
    pub nodes: String,
    pub partition: String,
    pub priority: Option<i64>,
    pub status: JobStatus,
    pub tasks: Option<Vec<JobTask>>,
    pub time: JobTime,
    pub user: Option<String>,
    #[serde(rename = "workingDirectory")]
    pub working_directory: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct JobStatus {
    #[serde(rename = "exitCode")]
    pub exit_code: Option<i64>,
    #[serde(rename = "interruptSignal")]
    pub interrupt_signal: Option<i64>,
    pub state: String,
    #[serde(rename = "stateReason")]
    pub state_reason: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct JobTask {
    pub id: String,
    pub name: String,
    pub status: JobStatus,
    pub time: JobTime,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct JobTime {
    pub elapsed: Option<i64>,
    pub end: Option<i64>,
    pub limit: Option<i64>,
    pub start: Option<i64>,
    pub suspended: Option<i64>,
}
///Create move file or directory operation (`mv`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct MoveMvFilesystemSystemNameTransferMvPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: MoveMvFilesystemSystemNameTransferMvPostRequestBody,
}
impl MoveMvFilesystemSystemNameTransferMvPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/mv",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<MoveMvFilesystemSystemNameTransferMvPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<MoveResponse>::json_with_diagnostics(req).await?;
            return Ok(MoveMvFilesystemSystemNameTransferMvPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(MoveMvFilesystemSystemNameTransferMvPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(MoveMvFilesystemSystemNameTransferMvPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(MoveMvFilesystemSystemNameTransferMvPostResponse::Unknown)
    }
}
pub type MoveMvFilesystemSystemNameTransferMvPostRequestBody = MoveRequest;
///Response types for move_mv_filesystem__system_name__transfer_mv_post
#[derive(Clone, Debug)]
pub enum MoveMvFilesystemSystemNameTransferMvPostResponse {
    ///201: Move file or directory operation created successfully
    Created(MoveResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct MoveRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the move operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct MoveResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Configuration for multipart upload behavior.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct MultipartUpload {
    ///Maximum size (in bytes) for multipart data transfers. Default is 2 GB.
    #[default(Some(2147483648i64))]
    pub max_part_size: Option<i64>,
    ///Number of parts to upload in parallel to the staging area.
    #[default(Some(3i64))]
    pub parallel_runs: Option<i64>,
    ///Temporary folder used for storing split parts during upload.
    #[default(Some("tmp".to_string()))]
    pub tmp_folder: Option<String>,
    ///Enable or disable splitting large files into parts when uploading the file to the staging area.
    #[default(Some(false))]
    pub use_split: Option<bool>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct NodeModel {
    pub address: Option<String>,
    #[serde(rename = "allocCpus")]
    pub alloc_cpus: Option<i64>,
    #[serde(rename = "allocMemory")]
    pub alloc_memory: Option<i64>,
    pub cores: Option<i64>,
    #[serde(rename = "cpuLoad")]
    pub cpu_load: Option<f64>,
    pub cpus: i64,
    pub features: Option<NodeModelFeatures>,
    #[serde(rename = "freeMemory")]
    pub free_memory: Option<i64>,
    pub hostname: Option<String>,
    #[serde(rename = "idleCpus")]
    pub idle_cpus: Option<i64>,
    pub name: String,
    pub partitions: Option<Vec<String>>,
    pub sockets: Option<i64>,
    pub state: NodeModelState,
    pub threads: Option<i64>,
    pub weight: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum NodeModelFeatures {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum NodeModelState {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PartitionModel {
    pub cpus: Option<i64>,
    pub name: String,
    pub partition: PartitionModelPartition,
    #[serde(rename = "totalNodes")]
    pub total_nodes: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum PartitionModelPartition {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PosixIdentified {
    pub id: String,
    pub name: String,
}
///Compress files and directories using `tar` command
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostCompressFilesystemSystemNameOpsCompressPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostCompressFilesystemSystemNameOpsCompressPostRequestBody,
}
impl PostCompressFilesystemSystemNameOpsCompressPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/compress",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
pub type PostCompressFilesystemSystemNameOpsCompressPostRequestBody = PostCompressRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostCompressRequest {
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some(Default::default()))]
    pub compression: Option<CompressionType>,
    ///If set to `true`, it follows symbolic links and archive the files they point to instead of the links
    /// themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    ///Regex pattern to filter files to compress
    #[serde(rename = "matchPattern")]
    pub match_pattern: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
///Create copy file or directory operation (`cp`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostCpFilesystemSystemNameTransferCpPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostCpFilesystemSystemNameTransferCpPostRequestBody,
}
impl PostCpFilesystemSystemNameTransferCpPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/cp",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostCpFilesystemSystemNameTransferCpPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<CopyResponse>::json_with_diagnostics(req).await?;
            return Ok(PostCpFilesystemSystemNameTransferCpPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostCpFilesystemSystemNameTransferCpPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostCpFilesystemSystemNameTransferCpPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PostCpFilesystemSystemNameTransferCpPostResponse::Unknown)
    }
}
pub type PostCpFilesystemSystemNameTransferCpPostRequestBody = CopyRequest;
///Response types for post_cp_filesystem__system_name__transfer_cp_post
#[derive(Clone, Debug)]
pub enum PostCpFilesystemSystemNameTransferCpPostResponse {
    ///201: Copy file or directory operation created successfully
    Created(CopyResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Create asynchronous download operation (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostDownloadFilesystemSystemNameTransferDownloadPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostDownloadFilesystemSystemNameTransferDownloadPostRequestBody,
}
impl PostDownloadFilesystemSystemNameTransferDownloadPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/download",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostDownloadFilesystemSystemNameTransferDownloadPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<DownloadFileResponse>::json_with_diagnostics(req).await?;
            return Ok(PostDownloadFilesystemSystemNameTransferDownloadPostResponse::Created(
                data,
            ));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostDownloadFilesystemSystemNameTransferDownloadPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostDownloadFilesystemSystemNameTransferDownloadPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PostDownloadFilesystemSystemNameTransferDownloadPostResponse::Unknown)
    }
}
pub type PostDownloadFilesystemSystemNameTransferDownloadPostRequestBody = PostFileDownloadRequest;
///Response types for post_download_filesystem__system_name__transfer_download_post
#[derive(Clone, Debug)]
pub enum PostDownloadFilesystemSystemNameTransferDownloadPostResponse {
    ///201: Download operation created successfully
    Created(DownloadFileResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Extract `tar` `gzip` archives
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostExtractFilesystemSystemNameOpsExtractPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostExtractFilesystemSystemNameOpsExtractPostRequestBody,
}
impl PostExtractFilesystemSystemNameOpsExtractPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/extract",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
pub type PostExtractFilesystemSystemNameOpsExtractPostRequestBody = PostExtractRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostExtractRequest {
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some(Default::default()))]
    pub compression: Option<CompressionType>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the directory where to extract the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1u64))]
    pub target_path: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileDownloadRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Data transfer parameters specific to the transfer method
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: PostFileDownloadRequestTransferDirectives,
}
///Data transfer parameters specific to the transfer method
#[derive(Debug, Clone, PartialEq, Serialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum PostFileDownloadRequestTransferDirectives {
    #[default]
    Wormhole(WormholeTransferRequest),
    S3(S3TransferRequest),
    Streamer(StreamerTransferRequest),
}
impl PostFileDownloadRequestTransferDirectives {
    ///Creates a `Wormhole` variant with default values.
    pub fn wormhole() -> Self {
        Self::Wormhole(WormholeTransferRequest::default())
    }
    ///Creates a `S3` variant with default values.
    pub fn s3() -> Self {
        Self::S3(S3TransferRequest::default())
    }
    ///Creates a `Streamer` variant with default values.
    pub fn streamer() -> Self {
        Self::Streamer(StreamerTransferRequest::default())
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileSymlinkRequest {
    ///Path to the new symlink
    #[serde(rename = "linkPath")]
    #[validate(length(min = 1u64))]
    pub link_path: String,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PostFileSymlinkResponse {
    pub output: Option<File>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileUploadRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Data transfer parameters specific to the transfer method
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: PostFileDownloadRequestTransferDirectives,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobAttachRequest {
    ///Command to attach to the job
    pub command: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PostJobSubmissionResponse {
    #[serde(rename = "jobId")]
    pub job_id: Option<i64>,
}
///Submit a new job
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobSubmitComputeSystemNameJobsPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostJobSubmitComputeSystemNameJobsPostRequestBody,
}
impl PostJobSubmitComputeSystemNameJobsPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "compute/{}/jobs",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostJobSubmitComputeSystemNameJobsPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<PostJobSubmissionResponse>::json_with_diagnostics(req).await?;
            return Ok(PostJobSubmitComputeSystemNameJobsPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostJobSubmitComputeSystemNameJobsPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostJobSubmitComputeSystemNameJobsPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PostJobSubmitComputeSystemNameJobsPostResponse::Unknown)
    }
}
pub type PostJobSubmitComputeSystemNameJobsPostRequestBody = PostJobSubmitRequest;
///Response types for post_job_submit_compute__system_name__jobs_post
#[derive(Clone, Debug)]
pub enum PostJobSubmitComputeSystemNameJobsPostResponse {
    ///201: Job submitted correctly
    Created(PostJobSubmissionResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobSubmitRequest {
    pub job: JobDescriptionModel,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostMakeDirRequest {
    ///If set to `true` creates all its parent directories if they do not already exist
    #[default(Some(false))]
    pub parent: Option<bool>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
///Create directory operation (`mkdir`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostMkdirFilesystemSystemNameOpsMkdirPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostMkdirFilesystemSystemNameOpsMkdirPostRequestBody,
}
impl PostMkdirFilesystemSystemNameOpsMkdirPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/mkdir",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostMkdirFilesystemSystemNameOpsMkdirPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<PostMkdirResponse>::json_with_diagnostics(req).await?;
            return Ok(PostMkdirFilesystemSystemNameOpsMkdirPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostMkdirFilesystemSystemNameOpsMkdirPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostMkdirFilesystemSystemNameOpsMkdirPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PostMkdirFilesystemSystemNameOpsMkdirPostResponse::Unknown)
    }
}
pub type PostMkdirFilesystemSystemNameOpsMkdirPostRequestBody = PostMakeDirRequest;
///Response types for post_mkdir_filesystem__system_name__ops_mkdir_post
#[derive(Clone, Debug)]
pub enum PostMkdirFilesystemSystemNameOpsMkdirPostResponse {
    ///201: Directory created successfully
    Created(PostMkdirResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PostMkdirResponse {
    pub output: Option<File>,
}
///Create symlink operation (`ln`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostSymlinkFilesystemSystemNameOpsSymlinkPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostSymlinkFilesystemSystemNameOpsSymlinkPostRequestBody,
}
impl PostSymlinkFilesystemSystemNameOpsSymlinkPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/symlink",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<PostFileSymlinkResponse>::json_with_diagnostics(req).await?;
            return Ok(PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse::Unknown)
    }
}
pub type PostSymlinkFilesystemSystemNameOpsSymlinkPostRequestBody = PostFileSymlinkRequest;
///Response types for post_symlink_filesystem__system_name__ops_symlink_post
#[derive(Clone, Debug)]
pub enum PostSymlinkFilesystemSystemNameOpsSymlinkPostResponse {
    ///201: Symlink created successfully
    Created(PostFileSymlinkResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Upload a small file (max 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostUploadFilesystemSystemNameOpsUploadPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    ///Specify path where file should be uploaded.
    /// - Location: `Query`
    #[validate(length(min = 1u64))]
    pub path: String,
    pub body: PostUploadFilesystemSystemNameOpsUploadPostRequestBody,
}
impl PostUploadFilesystemSystemNameOpsUploadPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        use std::fmt::Write as _;
        let mut path = format!(
            "filesystem/{}/ops/upload",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&oas3_gen_support::serialize_query_param(&self.path)?)
        )
        .unwrap();
        Ok(path)
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<DeleteRmFilesystemSystemNameOpsRmDeleteResponse> {
        let status = req.status();
        if status.is_success() {
            let _ = req.bytes().await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::NoContent);
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(DeleteRmFilesystemSystemNameOpsRmDeleteResponse::Unknown)
    }
}
pub type PostUploadFilesystemSystemNameOpsUploadPostRequestBody = BodyPostUploadFilesystemSystemNameOpsUploadPost;
///Create asynchronous upload operation (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PostUploadFilesystemSystemNameTransferUploadPostRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PostUploadFilesystemSystemNameTransferUploadPostRequestBody,
}
impl PostUploadFilesystemSystemNameTransferUploadPostRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/transfer/upload",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PostUploadFilesystemSystemNameTransferUploadPostResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<UploadFileResponse>::json_with_diagnostics(req).await?;
            return Ok(PostUploadFilesystemSystemNameTransferUploadPostResponse::Created(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostUploadFilesystemSystemNameTransferUploadPostResponse::ClientError(
                data,
            ));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PostUploadFilesystemSystemNameTransferUploadPostResponse::ServerError(
                data,
            ));
        }
        let _ = req.bytes().await?;
        Ok(PostUploadFilesystemSystemNameTransferUploadPostResponse::Unknown)
    }
}
pub type PostUploadFilesystemSystemNameTransferUploadPostRequestBody = PostFileUploadRequest;
///Response types for post_upload_filesystem__system_name__transfer_upload_post
#[derive(Clone, Debug)]
pub enum PostUploadFilesystemSystemNameTransferUploadPostResponse {
    ///201: Upload operation created successfully
    Created(UploadFileResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Cluster monitoring attributes.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Probing {
    ///Interval in seconds between cluster checks.
    pub interval: i64,
    ///Maximum time in seconds allowed per check.
    pub timeout: i64,
}
///Change the permission mode of a file(`chmod`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PutChmodFilesystemSystemNameOpsChmodPutRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PutChmodFilesystemSystemNameOpsChmodPutRequestBody,
}
impl PutChmodFilesystemSystemNameOpsChmodPutRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/chmod",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PutChmodFilesystemSystemNameOpsChmodPutResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<PutFileChmodResponse>::json_with_diagnostics(req).await?;
            return Ok(PutChmodFilesystemSystemNameOpsChmodPutResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PutChmodFilesystemSystemNameOpsChmodPutResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PutChmodFilesystemSystemNameOpsChmodPutResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PutChmodFilesystemSystemNameOpsChmodPutResponse::Unknown)
    }
}
pub type PutChmodFilesystemSystemNameOpsChmodPutRequestBody = PutFileChmodRequest;
///Response types for put_chmod_filesystem__system_name__ops_chmod_put
#[derive(Clone, Debug)]
pub enum PutChmodFilesystemSystemNameOpsChmodPutResponse {
    ///200: File permissions changed successfully
    Ok(PutFileChmodResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
///Change the ownership of a given file (`chown`)
#[derive(Debug, Clone, validator::Validate, oas3_gen_support::Default)]
pub struct PutChownFilesystemSystemNameOpsChownPutRequest {
    /// - Location: `Path`
    #[validate(length(min = 1u64))]
    pub system_name: String,
    pub body: PutChownFilesystemSystemNameOpsChownPutRequestBody,
}
impl PutChownFilesystemSystemNameOpsChownPutRequest {
    ///Render the request path with parameters.
    pub fn render_path(&self) -> anyhow::Result<String> {
        Ok(format!(
            "filesystem/{}/ops/chown",
            oas3_gen_support::percent_encode_path_segment(&oas3_gen_support::serialize_query_param(&self.system_name)?)
        ))
    }
    ///Parse the HTTP response into the response enum.
    pub async fn parse_response(
        req: reqwest::Response,
    ) -> anyhow::Result<PutChownFilesystemSystemNameOpsChownPutResponse> {
        let status = req.status();
        if status.is_success() {
            let data = oas3_gen_support::Diagnostics::<PutFileChownResponse>::json_with_diagnostics(req).await?;
            return Ok(PutChownFilesystemSystemNameOpsChownPutResponse::Ok(data));
        }
        if status.is_client_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PutChownFilesystemSystemNameOpsChownPutResponse::ClientError(data));
        }
        if status.is_server_error() {
            let data = oas3_gen_support::Diagnostics::<ApiResponseError>::json_with_diagnostics(req).await?;
            return Ok(PutChownFilesystemSystemNameOpsChownPutResponse::ServerError(data));
        }
        let _ = req.bytes().await?;
        Ok(PutChownFilesystemSystemNameOpsChownPutResponse::Unknown)
    }
}
pub type PutChownFilesystemSystemNameOpsChownPutRequestBody = PutFileChownRequest;
///Response types for put_chown_filesystem__system_name__ops_chown_put
#[derive(Clone, Debug)]
pub enum PutChownFilesystemSystemNameOpsChownPutResponse {
    ///200: File ownership changed successfully
    Ok(PutFileChownResponse),
    ///4XX: Client Error
    ClientError(ApiResponseError),
    ///5XX: Server Error
    ServerError(ApiResponseError),
    ///default: Unknown response
    Unknown,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutFileChmodRequest {
    ///Mode in octal permission format
    #[validate(length(min = 1u64))]
    pub mode: String,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PutFileChmodResponse {
    pub output: Option<File>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PutFileChownRequest {
    ///Group name of the new group owner of the file
    #[default(Some(String::new()))]
    pub group: Option<String>,
    ///User name of the new user owner of the file
    #[default(Some(String::new()))]
    pub owner: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct PutFileChownResponse {
    pub output: Option<File>,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct ReservationModel {
    #[serde(rename = "endTime")]
    pub end_time: i64,
    pub features: Option<String>,
    pub name: String,
    #[serde(rename = "nodeList")]
    pub node_list: String,
    #[serde(rename = "startTime")]
    pub start_time: i64,
}
///Object storage configuration, including credentials, endpoints, and upload behavior.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3DataTransfer {
    ///Access key ID for S3-compatible storage.
    #[serde(rename = "accessKeyId")]
    pub access_key_id: String,
    ///Configuration for automatic object lifecycle in storage buckets.
    #[serde(rename = "bucketLifecycleConfiguration")]
    pub bucket_lifecycle_configuration: Option<BucketLifecycleConfiguration>,
    ///Configuration for multipart upload behavior.
    pub multipart: Option<MultipartUpload>,
    ///Name identifier for the storage.
    pub name: String,
    ///Private/internal endpoint URL for the storage.
    #[serde(rename = "privateUrl")]
    pub private_url: String,
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    ///Public/external URL for the storage.
    #[serde(rename = "publicUrl")]
    pub public_url: String,
    ///Region of the storage bucket.
    pub region: String,
    ///Secret access key for storage. You can give directly the content or the file path using
    /// `'secret_file:/path/to/file'`.
    #[serde(rename = "secretAccessKey")]
    pub secret_access_key: String,
    #[serde(rename = "serviceType")]
    #[default("s3".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
    ///Optional tenant identifier for multi-tenant setups.
    pub tenant: Option<String>,
    ///Time-to-live (in seconds) for generated URLs.
    pub ttl: i64,
}
///Health status of S3-compatible storage.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3ServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3TransferRequest {
    ///Size of the file to upload in bytes
    #[serde(rename = "fileSize")]
    pub file_size: Option<i64>,
    #[serde(rename = "transferMethod")]
    #[validate(length(min = 1u64))]
    #[default("s3".to_string())]
    pub transfer_method: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3TransferResponse {
    #[serde(rename = "completeUploadUrl")]
    pub complete_upload_url: Option<String>,
    #[serde(rename = "downloadUrl")]
    pub download_url: Option<String>,
    #[serde(rename = "maxPartSize")]
    pub max_part_size: Option<i64>,
    #[serde(rename = "partsUploadUrls")]
    pub parts_upload_urls: Option<Vec<String>>,
    #[serde(rename = "transferMethod")]
    #[default("s3".to_string())]
    pub transfer_method: String,
}
///SSH connection pool configuration for remote execution.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct SSHClientPool {
    ///SSH target hostname.
    pub host: String,
    ///Maximum number of concurrent SSH clients.
    #[serde(rename = "maxClients")]
    #[default(Some(100i64))]
    pub max_clients: Option<i64>,
    ///SSH port.
    pub port: i64,
    ///Optional proxy host for tunneling.
    #[serde(rename = "proxyHost")]
    pub proxy_host: Option<String>,
    ///Optional proxy port.
    #[serde(rename = "proxyPort")]
    pub proxy_port: Option<i64>,
    ///Various SSH settings.
    pub timeout: Option<SSHTimeouts>,
}
///Health status of SSH service.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct SSHServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: String,
}
///Various SSH settings.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct SSHTimeouts {
    ///Timeout (seconds) for executing commands over SSH.
    #[serde(rename = "commandExecution")]
    #[default(Some(5i64))]
    pub command_execution: Option<i64>,
    ///Timeout (seconds) for initial SSH connection.
    #[default(Some(5i64))]
    pub connection: Option<i64>,
    ///Max idle time (seconds) before disconnecting.
    #[serde(rename = "idleTimeout")]
    #[default(Some(60i64))]
    pub idle_timeout: Option<i64>,
    ///Interval (seconds) for sending keep-alive messages.
    #[serde(rename = "keepAlive")]
    #[default(Some(5i64))]
    pub keep_alive: Option<i64>,
    ///Timeout (seconds) for SSH login/auth.
    #[default(Some(5i64))]
    pub login: Option<i64>,
}
///Cluster job scheduler configuration.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct Scheduler {
    ///REST API endpoint for scheduler.
    #[serde(rename = "apiUrl")]
    pub api_url: Option<String>,
    ///Scheduler API version.
    #[serde(rename = "apiVersion")]
    pub api_version: Option<String>,
    ///Timeout in seconds for scheduler communication with the API.
    #[default(Some(10i64))]
    pub timeout: Option<i64>,
    ///Supported job scheduler types.
    #[serde(rename = "type")]
    pub r#type: String,
    ///Scheduler version.
    pub version: String,
}
///Health check result for the job scheduler.
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct SchedulerServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: String,
}
///Supported job scheduler types.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum SchedulerType {
    #[serde(rename = "slurm")]
    #[default]
    Slurm,
    #[serde(rename = "pbs")]
    Pbs,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct StreamerDataTransfer {
    ///The interface to use for listening incoming connections
    pub host: Option<String>,
    ///Limit how much data can be received (in bytes)
    #[serde(rename = "inboundTransferLimit")]
    #[default(Some(5368709120i64))]
    pub inbound_transfer_limit: Option<i64>,
    ///Port range for establishing connections.
    #[serde(rename = "portRange")]
    #[validate(length(min = 2u64, max = 2u64))]
    #[default(Some(Default::default()))]
    pub port_range: Option<Vec<serde_json::Value>>,
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    ///List of public IP addresses where server can be reached.
    #[serde(rename = "publicIps")]
    pub public_ips: Option<Vec<String>>,
    ///Optional local PyPI index URL for installing dependencies.
    #[serde(rename = "pypiIndexUrl")]
    pub pypi_index_url: Option<String>,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1u64))]
    #[default("streamer".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
    ///How long to wait for a connection before exiting (in seconds)
    #[serde(rename = "waitTimeout")]
    #[default(Some(86400i64))]
    pub wait_timeout: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct StreamerTransferRequest {
    #[serde(rename = "transferMethod")]
    #[validate(length(min = 1u64))]
    #[default("streamer".to_string())]
    pub transfer_method: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct StreamerTransferResponse {
    pub coordinates: Option<String>,
    #[serde(rename = "transferMethod")]
    #[default("streamer".to_string())]
    pub transfer_method: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct UploadFileResponse {
    ///Data transfer parameters specific to the transfer method
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: DownloadFileResponseTransferDirectives,
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
pub struct UserInfoResponse {
    pub group: PosixIdentified,
    pub groups: Vec<PosixIdentified>,
    pub user: PosixIdentified,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeDataTransfer {
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    ///Optional local PyPI index URL for installing dependencies.
    #[serde(rename = "pypiIndexUrl")]
    pub pypi_index_url: Option<String>,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1u64))]
    #[default("wormhole".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
}
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeTransferRequest {
    #[serde(rename = "transferMethod")]
    #[validate(length(min = 1u64))]
    #[default("wormhole".to_string())]
    pub transfer_method: String,
}
#[derive(Debug, Clone, PartialEq, Deserialize, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeTransferResponse {
    #[serde(rename = "transferMethod")]
    #[default("wormhole".to_string())]
    pub transfer_method: String,
    #[serde(rename = "wormholeCode")]
    pub wormhole_code: Option<String>,
}

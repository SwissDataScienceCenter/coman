// @generated by oas3-gen
#![allow(clippy::all)]
#![allow(dead_code)]
//! AUTO-GENERATED CODE - DO NOT EDIT!
//!
//! FirecREST
//! Source: /tmp/.tmp3GQPQB.json
//! Version: 2.4.0
//! Generated by `oas3-gen v0.9.0`
//!
//! No description provided
#![allow(clippy::large_enum_variant)]

use serde::{Deserialize, Serialize};
static REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID: std::sync::LazyLock<regex::Regex> =
    std::sync::LazyLock::new(|| regex::Regex::new("^[a-zA-Z0-9]+$").expect("invalid regex"));
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ApResponseErrorType {
    #[serde(rename = "error")]
    #[default]
    Error,
    #[serde(rename = "validation")]
    Validation,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct ApiResponseError {
    pub data: Option<serde_json::Value>,
    #[serde(rename = "errorType")]
    pub error_type: Option<ApResponseErrorType>,
    #[validate(length(min = 1))]
    pub message: String,
    pub user: Option<String>,
}
///Attach a procces to a job by `{job_id}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct AttachComputeSystemNameJobsJobIdAttachPutRequest {
    ///Job id
    ///## Schema
    ///- Location: Path
    #[validate(
        length(min = 1),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: AttachComputeSystemNameJobsJobIdAttachPutRequestBody,
}
impl AttachComputeSystemNameJobsJobIdAttachPutRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/compute/{}/jobs/{}/attach",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string()),
            oas3_gen_support::percent_encode_path_segment(&self.job_id.to_string())
        )
    }
}
pub type AttachComputeSystemNameJobsJobIdAttachPutRequestBody = PostJobAttachRequest;
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct BodyPostUploadFilesystemSystemNameOpsUploadPost {
    ///File to be uploaded as `multipart/form-data`
    pub file: Vec<u8>,
}
///Configuration for automatic object lifecycle in storage buckets.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct BucketLifecycleConfiguration {
    ///Number of days after which objects will expire automatically.
    #[default(Some(10i64))]
    pub days: Option<i64>,
}
///Create compress file or directory operation (`tar`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct CompressFilesystemSystemNameTransferCompressPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: CompressFilesystemSystemNameTransferCompressPostRequestBody,
}
impl CompressFilesystemSystemNameTransferCompressPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/compress",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type CompressFilesystemSystemNameTransferCompressPostRequestBody = CompressRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CompressRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some("gzip".to_string().into()))]
    pub compression: Option<CompressionType>,
    ///If set to `true`, it follows symbolic links and archive the files they point to instead of the links themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    ///Regex pattern to filter files to compress
    #[serde(rename = "matchPattern")]
    pub match_pattern: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the compress operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct CompressResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum CompressionType {
    #[serde(rename = "none")]
    #[default]
    None,
    #[serde(rename = "bzip2")]
    Bzip2,
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "xz")]
    Xz,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum ContentUnit {
    #[serde(rename = "lines")]
    #[default]
    Lines,
    #[serde(rename = "bytes")]
    Bytes,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct CopyRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///If set to `true`, it follows symbolic links and copies the files they point to instead of the links themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the copy operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct CopyResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct DataOperationInput {
    ///Data transfer service configuration
    pub data_transfer: Option<S3DataTransferInput>,
    ///Maximum file size (in bytes) allowed for direct upload and download. Larger files will go through the staging area.
    #[default(Some(5242880i64))]
    pub max_ops_file_size: Option<i64>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct DataOperationOutput {
    ///Data transfer service configuration
    pub data_transfer: Option<S3DataTransferOutput>,
    ///Maximum file size (in bytes) allowed for direct upload and download. Larger files will go through the staging area.
    #[default(Some(5242880i64))]
    pub max_ops_file_size: Option<i64>,
}
///Cancel a job
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteJobCancelComputeSystemNameJobsJobIdDeleteRequest {
    ///Job id
    ///## Schema
    ///- Location: Path
    #[validate(
        length(min = 1),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl DeleteJobCancelComputeSystemNameJobsJobIdDeleteRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/compute/{}/jobs/{}",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string()),
            oas3_gen_support::percent_encode_path_segment(&self.job_id.to_string())
        )
    }
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Delete file or directory operation (`rm`)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteRmFilesystemSystemNameOpsRmDeleteRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///The path to delete
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
}
impl DeleteRmFilesystemSystemNameOpsRmDeleteRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/rm",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        path
    }
}
///Create remove file or directory operation (`rm`) (for files larger than 5242880 Bytes)
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct DeleteRmFilesystemSystemNameTransferRmDeleteRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///The path to delete
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///## Schema
    ///- Location: Query
    pub account: Option<String>,
}
impl DeleteRmFilesystemSystemNameTransferRmDeleteRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/transfer/rm",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.account {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}account={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct DownloadFileResponse {
    ///Provide method specific transfer directives
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: Option<DownloadFileResponseTransferDirectives>,
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Provide method specific transfer directives
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(tag = "transferMethod")]
pub enum DownloadFileResponseTransferDirectives {
    #[serde(rename = "s3")]
    #[default]
    S3DataTransferDirective(S3DataTransferDirective),
    #[serde(rename = "wormhole")]
    WormholeDataTransferDirective(WormholeDataTransferDirective),
}
///Create extract file operation (`tar`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct ExtractFilesystemSystemNameTransferExtractPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: ExtractFilesystemSystemNameTransferExtractPostRequestBody,
}
impl ExtractFilesystemSystemNameTransferExtractPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/extract",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type ExtractFilesystemSystemNameTransferExtractPostRequestBody = ExtractRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct ExtractRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some("gzip".to_string().into()))]
    pub compression: Option<CompressionType>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the directory where to extract the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct ExtractResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct File {
    #[validate(length(min = 1))]
    pub group: String,
    #[serde(rename = "lastModified")]
    #[validate(length(min = 1))]
    pub last_modified: String,
    #[serde(rename = "linkTarget")]
    pub link_target: Option<String>,
    #[validate(length(min = 1))]
    pub name: String,
    #[validate(length(min = 1))]
    pub permissions: String,
    #[validate(length(min = 1))]
    pub size: String,
    #[serde(rename = "type")]
    #[validate(length(min = 1))]
    pub r#type: String,
    #[validate(length(min = 1))]
    pub user: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct FileChecksum {
    #[default(Some("SHA-256".to_string()))]
    pub algorithm: Option<String>,
    #[validate(length(min = 1))]
    pub checksum: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct FileContent {
    #[validate(length(min = 1))]
    pub content: String,
    #[serde(rename = "contentType")]
    pub content_type: ContentUnit,
    #[serde(rename = "endPosition")]
    pub end_position: i64,
    #[serde(rename = "startPosition")]
    pub start_position: i64,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct FileStat {
    pub atime: i64,
    pub ctime: i64,
    pub dev: i64,
    pub gid: i64,
    pub ino: i64,
    pub mode: i64,
    pub mtime: i64,
    pub nlink: i64,
    pub size: i64,
    pub uid: i64,
}
///Defines a cluster file system and its type.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct FileSystem {
    ///Data types for cluster file systems.
    #[serde(rename = "dataType")]
    pub data_type: FileSystemDataType,
    ///Mark this as the default working directory.
    #[serde(rename = "defaultWorkDir")]
    #[default(Some(false))]
    pub default_work_dir: Option<bool>,
    ///Mount path for the file system.
    #[validate(length(min = 1))]
    pub path: String,
}
///Data types for cluster file systems.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum FileSystemDataType {
    #[serde(rename = "users")]
    #[default]
    Users,
    #[serde(rename = "store")]
    Store,
    #[serde(rename = "archive")]
    Archive,
    #[serde(rename = "apps")]
    Apps,
    #[serde(rename = "scratch")]
    Scratch,
    #[serde(rename = "project")]
    Project,
}
///Health check for a mounted file system.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct FilesystemServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Path of the monitored file system.
    pub path: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: HealthCheckType,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct FirecrestFilesystemTransferModelsTransferJob {
    #[serde(rename = "jobId")]
    pub job_id: i64,
    pub logs: LibDatatransfersDatatransferBaseTransferJobLogs,
    #[validate(length(min = 1))]
    pub system: String,
    #[serde(rename = "workingDirectory")]
    #[validate(length(min = 1))]
    pub working_directory: String,
}
///Output the checksum of a file (using SHA-256 algotithm)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetChecksumFilesystemSystemNameOpsChecksumGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///Target system
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
}
impl GetChecksumFilesystemSystemNameOpsChecksumGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/checksum",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        path
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetDirectoryLsResponse {
    pub output: Option<Vec<File>>,
}
///Download a small file (max 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetDownloadFilesystemSystemNameOpsDownloadGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///A file to download
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
}
impl GetDownloadFilesystemSystemNameOpsDownloadGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/download",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        path
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileChecksumResponse {
    pub output: Option<FileChecksum>,
}
///Output the type of a file or directory
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileFilesystemSystemNameOpsFileGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///A file or folder path
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
}
impl GetFileFilesystemSystemNameOpsFileGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/file",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        path
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileHeadResponse {
    pub output: Option<FileContent>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileStatResponse {
    pub output: Option<FileStat>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileTailResponse {
    pub output: Option<FileContent>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetFileTypeResponse {
    pub output: Option<String>,
}
///Output the first part of file/s (`head`)
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetHeadFilesystemSystemNameOpsHeadGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///File path
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///The output will be the first NUM bytes of each file.
    ///## Schema
    ///- Location: Query
    pub bytes: Option<i64>,
    ///The output will be the first NUM lines of each file.
    ///## Schema
    ///- Location: Query
    pub lines: Option<i64>,
    ///The output will be the whole file, without the last NUM bytes/lines of each file. NUM should be specified in the respective argument through `bytes` or `lines`.
    ///## Schema
    ///- Location: Query
    #[serde(rename = "skipTrailing")]
    #[default(Some(false))]
    pub skip_trailing: Option<bool>,
}
impl GetHeadFilesystemSystemNameOpsHeadGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/head",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.bytes {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}bytes={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.lines {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}lines={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.skip_trailing {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}skipTrailing={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
///Get status of a job by `{job_id}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobComputeSystemNameJobsJobIdGetRequest {
    ///Job id
    ///## Schema
    ///- Location: Path
    #[validate(
        length(min = 1),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetJobComputeSystemNameJobsJobIdGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/compute/{}/jobs/{}",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string()),
            oas3_gen_support::percent_encode_path_segment(&self.job_id.to_string())
        )
    }
}
///Get metadata of a job by `{job_id}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobMetadataComputeSystemNameJobsJobIdMetadataGetRequest {
    ///Job id
    ///## Schema
    ///- Location: Path
    #[validate(
        length(min = 1),
        regex(path = "REGEX_ATTACH_COMPUTE_SYSTEM_NAME_JOBS_JOB_ID_ATTACH_PUT_REQUEST_JOB_ID")
    )]
    pub job_id: String,
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetJobMetadataComputeSystemNameJobsJobIdMetadataGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/compute/{}/jobs/{}/metadata",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string()),
            oas3_gen_support::percent_encode_path_segment(&self.job_id.to_string())
        )
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobMetadataResponse {
    pub jobs: Option<Vec<JobMetadataModel>>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetJobResponse {
    pub jobs: Option<Vec<JobModelOutput>>,
}
///Get status of all jobs
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetJobsComputeSystemNameJobsGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///If set to `true` returns all jobs visible by the current user, otherwise only the current user owned jobs
    ///## Schema
    ///- Location: Query
    #[default(Some(false))]
    pub allusers: Option<bool>,
}
impl GetJobsComputeSystemNameJobsGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/compute/{}/jobs",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        if let Some(value) = &self.allusers {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}allusers={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetLiveness {
    #[serde(rename = "healthcheckRuns")]
    pub healthcheck_runs: Option<serde_json::Value>,
    #[serde(rename = "lastUpdate")]
    pub last_update: Option<i64>,
}
///List the contents of the given directory (`ls`)
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetLsFilesystemSystemNameOpsLsGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///The path to list
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///Show hidden files
    ///## Schema
    ///- Location: Query
    #[serde(rename = "showHidden")]
    #[default(Some(false))]
    pub show_hidden: Option<bool>,
    ///List numeric user and group IDs
    ///## Schema
    ///- Location: Query
    #[serde(rename = "numericUid")]
    #[default(Some(false))]
    pub numeric_uid: Option<bool>,
    ///Recursively list files and folders
    ///## Schema
    ///- Location: Query
    #[default(Some(false))]
    pub recursive: Option<bool>,
    ///Show information for the file the link references.
    ///## Schema
    ///- Location: Query
    #[default(Some(false))]
    pub dereference: Option<bool>,
}
impl GetLsFilesystemSystemNameOpsLsGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/ls",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.show_hidden {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}showHidden={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.numeric_uid {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}numericUid={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.recursive {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}recursive={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.dereference {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}dereference={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetNodesResponse {
    pub nodes: Vec<NodeModel>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetPartitionsResponse {
    pub partitions: Vec<PartitionModel>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetReservationsResponse {
    pub reservations: Vec<ReservationModel>,
}
///Output the `stat` of a file
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetStatFilesystemSystemNameOpsStatGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///A file or folder path
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///Follow symbolic links
    ///## Schema
    ///- Location: Query
    #[default(Some(false))]
    pub dereference: Option<bool>,
}
impl GetStatFilesystemSystemNameOpsStatGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/stat",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.dereference {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}dereference={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
///Get the list of nodes of a `{system_name}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemNodesStatusSystemNameNodesGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetSystemNodesStatusSystemNameNodesGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/status/{}/nodes",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
///Get the list of partitions of a `{system_name}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemPartitionsStatusSystemNamePartitionsGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetSystemPartitionsStatusSystemNamePartitionsGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/status/{}/partitions",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
///Get the list of reservations of a `{system_name}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemReservationsStatusSystemNameReservationsGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetSystemReservationsStatusSystemNameReservationsGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/status/{}/reservations",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetSystemsResponse {
    #[serde(rename = "dataOperation")]
    pub data_operation: Option<DataOperationOutput>,
    pub systems: Vec<HpcclusterOutput>,
}
///Output the last part of a file (`tail`)
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetTailFilesystemSystemNameOpsTailGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///File path
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///The output will be the last NUM bytes of each file.
    ///## Schema
    ///- Location: Query
    pub bytes: Option<i64>,
    ///The output will be the last NUM lines of each file.
    ///## Schema
    ///- Location: Query
    pub lines: Option<i64>,
    ///The output will be the whole file, without the first NUM bytes/lines of each file. NUM should be specified in the respective argument through `bytes` or `lines`.
    ///## Schema
    ///- Location: Query
    #[serde(rename = "skipHeading")]
    #[default(Some(false))]
    pub skip_heading: Option<bool>,
}
impl GetTailFilesystemSystemNameOpsTailGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/tail",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.bytes {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}bytes={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.lines {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}lines={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.skip_heading {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}skipHeading={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
///Get current user information on a `{system_name}`
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetUserinfoStatusSystemNameUserinfoGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
}
impl GetUserinfoStatusSystemNameUserinfoGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/status/{}/userinfo",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct GetViewFileResponse {
    pub output: Option<String>,
}
///View file content (up to max 5242880 bytes)
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct GetViewFilesystemSystemNameOpsViewGetRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///File path
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///Value, in bytes, of the size of data to be retrieved from the file.
    ///## Schema
    ///- Location: Query
    #[default(Some(5242880i64))]
    pub size: Option<i64>,
    ///Value in bytes of the offset.
    ///## Schema
    ///- Location: Query
    #[default(Some(0i64))]
    pub offset: Option<i64>,
}
impl GetViewFilesystemSystemNameOpsViewGetRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/view",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        if let Some(value) = &self.size {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}size={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        if let Some(value) = &self.offset {
            prefix = if prefix == '\0' { '?' } else { '&' };
            write!(
                &mut path,
                "{prefix}offset={}",
                oas3_gen_support::percent_encode_query_component(&value.to_string())
            )
            .unwrap();
        }
        path
    }
}
///Generic health check error placeholder.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct HealthCheckException {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: HealthCheckType,
}
///Types of services that can be health-checked.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum HealthCheckType {
    #[serde(rename = "scheduler")]
    #[default]
    Scheduler,
    #[serde(rename = "filesystem")]
    Filesystem,
    #[serde(rename = "ssh")]
    Ssh,
    #[serde(rename = "s3")]
    S3,
    #[serde(rename = "exception")]
    Exception,
}
///Definition of an HPC cluster, including SSH access, scheduling, and
///filesystem layout. More info in
///[the systems' section](../arch/systems//README.md).
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct HpcclusterInput {
    ///Custom scheduler flags passed to data transfer jobs (e.g. `-pxfer` for a dedicated partition).
    #[serde(rename = "datatransferJobsDirectives")]
    pub datatransfer_jobs_directives: Option<Vec<String>>,
    ///List of mounted file systems on the cluster, such as scratch or home directories.
    #[serde(rename = "fileSystems")]
    pub file_systems: Option<Vec<FileSystem>>,
    ///Unique name for the cluster. This field is case insensitive.
    #[validate(length(min = 1))]
    pub name: String,
    ///Cluster monitoring attributes.
    pub probing: Probing,
    ///Cluster job scheduler configuration.
    pub scheduler: Scheduler,
    ///Internal service account credentials.
    #[serde(rename = "serviceAccount")]
    pub service_account: ServiceAccount,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<SchedulerServiceHealth>>,
    ///SSH connection pool configuration for remote execution.
    pub ssh: SshclientPool,
}
///Definition of an HPC cluster, including SSH access, scheduling, and
///filesystem layout. More info in
///[the systems' section](../arch/systems//README.md).
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct HpcclusterOutput {
    ///Custom scheduler flags passed to data transfer jobs (e.g. `-pxfer` for a dedicated partition).
    #[serde(rename = "datatransferJobsDirectives")]
    pub datatransfer_jobs_directives: Option<Vec<String>>,
    ///List of mounted file systems on the cluster, such as scratch or home directories.
    #[serde(rename = "fileSystems")]
    pub file_systems: Option<Vec<FileSystem>>,
    ///Unique name for the cluster. This field is case insensitive.
    #[validate(length(min = 1))]
    pub name: String,
    ///Cluster monitoring attributes.
    pub probing: Probing,
    ///Cluster job scheduler configuration.
    pub scheduler: Scheduler,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<SchedulerServiceHealth>>,
    ///SSH connection pool configuration for remote execution.
    pub ssh: SshclientPool,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct JobDescriptionModel {
    ///Charge job resources to specified account
    pub account: Option<String>,
    ///Job constraints
    pub constraints: Option<String>,
    ///Dictionary of environment variables to set in the job context
    #[default(Some(Default::default()))]
    pub env: Option<JobDescriptionModelEnv>,
    ///Name for the job
    pub name: Option<String>,
    ///Script for the job
    pub script: Option<String>,
    ///Path to the job in target system
    #[serde(rename = "scriptPath")]
    pub script_path: Option<String>,
    ///Standard error file name
    #[serde(rename = "standardError")]
    pub standard_error: Option<String>,
    ///Standard input file name
    #[serde(rename = "standardInput")]
    pub standard_input: Option<String>,
    ///Standard output file name
    #[serde(rename = "standardOutput")]
    pub standard_output: Option<String>,
    ///Job working directory
    #[serde(rename = "workingDirectory")]
    #[validate(length(min = 1))]
    pub working_directory: String,
}
///Dictionary of environment variables to set in the job context
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum JobDescriptionModelEnv {
    #[default]
    Object(serde_json::Value),
    Array(Vec<String>),
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobMetadataModel {
    #[serde(rename = "jobId")]
    #[validate(length(min = 1))]
    pub job_id: String,
    pub script: Option<String>,
    #[serde(rename = "standardError")]
    pub standard_error: Option<String>,
    #[serde(rename = "standardInput")]
    pub standard_input: Option<String>,
    #[serde(rename = "standardOutput")]
    pub standard_output: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobModelInput {
    pub account: Option<String>,
    #[serde(rename = "allocationNodes")]
    pub allocation_nodes: i64,
    #[validate(length(min = 1))]
    pub cluster: String,
    pub group: Option<String>,
    #[serde(rename = "jobId")]
    pub job_id: i64,
    #[serde(rename = "killRequestUser")]
    pub kill_request_user: Option<String>,
    #[validate(length(min = 1))]
    pub name: String,
    #[validate(length(min = 1))]
    pub nodes: String,
    #[validate(length(min = 1))]
    pub partition: String,
    pub priority: Option<i64>,
    pub status: JobStatus,
    pub tasks: Option<Vec<JobTask>>,
    pub time: JobTime,
    pub user: Option<String>,
    #[serde(rename = "workingDirectory")]
    #[validate(length(min = 1))]
    pub working_directory: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobModelOutput {
    pub account: Option<String>,
    #[serde(rename = "allocationNodes")]
    pub allocation_nodes: i64,
    #[validate(length(min = 1))]
    pub cluster: String,
    pub group: Option<String>,
    #[serde(rename = "jobId")]
    pub job_id: i64,
    #[serde(rename = "killRequestUser")]
    pub kill_request_user: Option<String>,
    #[validate(length(min = 1))]
    pub name: String,
    #[validate(length(min = 1))]
    pub nodes: String,
    #[validate(length(min = 1))]
    pub partition: String,
    pub priority: Option<i64>,
    pub status: JobStatus,
    pub tasks: Option<Vec<JobTask>>,
    pub time: JobTime,
    pub user: Option<String>,
    #[serde(rename = "workingDirectory")]
    #[validate(length(min = 1))]
    pub working_directory: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobStatus {
    #[serde(rename = "exitCode")]
    pub exit_code: Option<i64>,
    #[serde(rename = "interruptSignal")]
    pub interrupt_signal: Option<i64>,
    #[validate(length(min = 1))]
    pub state: String,
    #[serde(rename = "stateReason")]
    pub state_reason: Option<String>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobTask {
    #[validate(length(min = 1))]
    pub id: String,
    #[validate(length(min = 1))]
    pub name: String,
    pub status: JobStatus,
    pub time: JobTime,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct JobTime {
    pub elapsed: Option<i64>,
    pub end: Option<i64>,
    pub limit: Option<i64>,
    pub start: Option<i64>,
    pub suspended: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct LibDatatransfersDatatransferBaseTransferJobLogs {
    #[serde(rename = "errorLog")]
    #[validate(length(min = 1))]
    pub error_log: String,
    #[serde(rename = "outputLog")]
    #[validate(length(min = 1))]
    pub output_log: String,
}
///Create move file or directory operation (`mv`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct MoveMvFilesystemSystemNameTransferMvPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: MoveMvFilesystemSystemNameTransferMvPostRequestBody,
}
impl MoveMvFilesystemSystemNameTransferMvPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/mv",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type MoveMvFilesystemSystemNameTransferMvPostRequestBody = MoveRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct MoveRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Target path of the move operation
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct MoveResponse {
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Configuration for multipart upload behavior.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct MultipartUpload {
    ///Maximum size (in bytes) for multipart data transfers. Default is 2 GB.
    #[default(Some(2147483648i64))]
    pub max_part_size: Option<i64>,
    ///Number of parts to upload in parallel to the staging area.
    #[default(Some(3i64))]
    pub parallel_runs: Option<i64>,
    ///Temporary folder used for storing split parts during upload.
    #[default(Some("tmp".to_string()))]
    pub tmp_folder: Option<String>,
    ///Enable or disable splitting large files into parts when uploading the file to the staging area.
    #[default(Some(false))]
    pub use_split: Option<bool>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct NodeModel {
    pub address: Option<String>,
    #[serde(rename = "allocCpus")]
    pub alloc_cpus: Option<i64>,
    #[serde(rename = "allocMemory")]
    pub alloc_memory: Option<i64>,
    pub cores: Option<i64>,
    #[serde(rename = "cpuLoad")]
    pub cpu_load: Option<f64>,
    pub cpus: i64,
    pub features: Option<NodeModelFeatures>,
    #[serde(rename = "freeMemory")]
    pub free_memory: Option<i64>,
    pub hostname: Option<String>,
    #[serde(rename = "idleCpus")]
    pub idle_cpus: Option<i64>,
    #[validate(length(min = 1))]
    pub name: String,
    pub partitions: Option<Vec<String>>,
    pub sockets: Option<i64>,
    pub state: NodeModelState,
    pub threads: Option<i64>,
    pub weight: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum NodeModelFeatures {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum NodeModelState {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PartitionModel {
    pub cpus: Option<i64>,
    #[validate(length(min = 1))]
    pub name: String,
    pub partition: PartitionModelPartition,
    #[serde(rename = "totalNodes")]
    pub total_nodes: Option<i64>,
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum PartitionModelPartition {
    #[default]
    String(String),
    Array(Vec<String>),
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PosixIdentified {
    #[validate(length(min = 1))]
    pub id: String,
    #[validate(length(min = 1))]
    pub name: String,
}
///Compress files and directories using `tar` command
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostCompressFilesystemSystemNameOpsCompressPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostCompressFilesystemSystemNameOpsCompressPostRequestBody,
}
impl PostCompressFilesystemSystemNameOpsCompressPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/compress",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostCompressFilesystemSystemNameOpsCompressPostRequestBody = PostCompressRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostCompressRequest {
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some("gzip".to_string().into()))]
    pub compression: Option<CompressionType>,
    ///If set to `true`, it follows symbolic links and archive the files they point to instead of the links themselves.
    #[default(Some(false))]
    pub dereference: Option<bool>,
    ///Regex pattern to filter files to compress
    #[serde(rename = "matchPattern")]
    pub match_pattern: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
///Create copy file or directory operation (`cp`) (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostCpFilesystemSystemNameTransferCpPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostCpFilesystemSystemNameTransferCpPostRequestBody,
}
impl PostCpFilesystemSystemNameTransferCpPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/cp",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostCpFilesystemSystemNameTransferCpPostRequestBody = CopyRequest;
///Create asynchronous download operation (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostDownloadFilesystemSystemNameTransferDownloadPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostDownloadFilesystemSystemNameTransferDownloadPostRequestBody,
}
impl PostDownloadFilesystemSystemNameTransferDownloadPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/download",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostDownloadFilesystemSystemNameTransferDownloadPostRequestBody = PostFileDownloadRequest;
///Extract `tar` `gzip` archives
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostExtractFilesystemSystemNameOpsExtractPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostExtractFilesystemSystemNameOpsExtractPostRequestBody,
}
impl PostExtractFilesystemSystemNameOpsExtractPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/extract",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostExtractFilesystemSystemNameOpsExtractPostRequestBody = PostExtractRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostExtractRequest {
    ///Defines the type of compression to be used. By default gzip is used.
    #[default(Some("gzip".to_string().into()))]
    pub compression: Option<CompressionType>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Path to the directory where to extract the compressed file
    #[serde(rename = "targetPath")]
    #[validate(length(min = 1))]
    pub target_path: String,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileDownloadRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileSymlinkRequest {
    ///Path to the new symlink
    #[serde(rename = "linkPath")]
    #[validate(length(min = 1))]
    pub link_path: String,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileSymlinkResponse {
    pub output: Option<File>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostFileUploadRequest {
    ///Name of the account in the scheduler
    pub account: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
    ///Data transfer parameters specific to the transfer method
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: PostFileUploadRequestTransferDirectives,
}
///Data transfer parameters specific to the transfer method
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(untagged)]
pub enum PostFileUploadRequestTransferDirectives {
    #[default]
    WormholeDataTransferDirective(WormholeDataTransferDirective),
    S3DataTransferDirective(S3DataTransferDirective),
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobAttachRequest {
    ///Command to attach to the job
    pub command: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobSubmissionResponse {
    #[serde(rename = "jobId")]
    pub job_id: Option<i64>,
}
///Submit a new job
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobSubmitComputeSystemNameJobsPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostJobSubmitComputeSystemNameJobsPostRequestBody,
}
impl PostJobSubmitComputeSystemNameJobsPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/compute/{}/jobs",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostJobSubmitComputeSystemNameJobsPostRequestBody = PostJobSubmitRequest;
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostJobSubmitRequest {
    pub job: JobDescriptionModel,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PostMakeDirRequest {
    ///If set to `true` creates all its parent directories if they do not already exist
    #[default(Some(false))]
    pub parent: Option<bool>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
///Create directory operation (`mkdir`)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostMkdirFilesystemSystemNameOpsMkdirPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostMkdirFilesystemSystemNameOpsMkdirPostRequestBody,
}
impl PostMkdirFilesystemSystemNameOpsMkdirPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/mkdir",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostMkdirFilesystemSystemNameOpsMkdirPostRequestBody = PostMakeDirRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostMkdirResponse {
    pub output: Option<File>,
}
///Create symlink operation (`ln`)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostSymlinkFilesystemSystemNameOpsSymlinkPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostSymlinkFilesystemSystemNameOpsSymlinkPostRequestBody,
}
impl PostSymlinkFilesystemSystemNameOpsSymlinkPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/symlink",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostSymlinkFilesystemSystemNameOpsSymlinkPostRequestBody = PostFileSymlinkRequest;
///Upload a small file (max 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostUploadFilesystemSystemNameOpsUploadPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///Specify path where file should be uploaded.
    ///## Schema
    ///- Location: Query
    #[validate(length(min = 1))]
    pub path: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `multipart/form-data`
    pub body: PostUploadFilesystemSystemNameOpsUploadPostRequestBody,
}
impl PostUploadFilesystemSystemNameOpsUploadPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        use std::fmt::Write as _;
        let mut path = format!(
            "/filesystem/{}/ops/upload",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        );
        let mut prefix = '\0';
        prefix = if prefix == '\0' { '?' } else { '&' };
        write!(
            &mut path,
            "{prefix}path={}",
            oas3_gen_support::percent_encode_query_component(&self.path.to_string())
        )
        .unwrap();
        path
    }
}
pub type PostUploadFilesystemSystemNameOpsUploadPostRequestBody = BodyPostUploadFilesystemSystemNameOpsUploadPost;
///Create asynchronous upload operation (for files larger than 5242880 Bytes)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PostUploadFilesystemSystemNameTransferUploadPostRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PostUploadFilesystemSystemNameTransferUploadPostRequestBody,
}
impl PostUploadFilesystemSystemNameTransferUploadPostRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/transfer/upload",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PostUploadFilesystemSystemNameTransferUploadPostRequestBody = PostFileUploadRequest;
///Cluster monitoring attributes.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Probing {
    ///Interval in seconds between cluster checks.
    pub interval: i64,
    ///Maximum time in seconds allowed per check.
    pub timeout: i64,
}
///Change the permission mode of a file(`chmod`)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutChmodFilesystemSystemNameOpsChmodPutRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PutChmodFilesystemSystemNameOpsChmodPutRequestBody,
}
impl PutChmodFilesystemSystemNameOpsChmodPutRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/chmod",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PutChmodFilesystemSystemNameOpsChmodPutRequestBody = PutFileChmodRequest;
///Change the ownership of a given file (`chown`)
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutChownFilesystemSystemNameOpsChownPutRequest {
    ///## Schema
    ///- Location: Path
    #[validate(length(min = 1))]
    pub system_name: String,
    ///## Schema
    ///- Required: `yes`
    ///- Content-Type: `application/json`
    pub body: PutChownFilesystemSystemNameOpsChownPutRequestBody,
}
impl PutChownFilesystemSystemNameOpsChownPutRequest {
    ///Render the request path with percent-encoded parameters.
    #[must_use]
    pub fn render_path(&self) -> String {
        format!(
            "/filesystem/{}/ops/chown",
            oas3_gen_support::percent_encode_path_segment(&self.system_name.to_string())
        )
    }
}
pub type PutChownFilesystemSystemNameOpsChownPutRequestBody = PutFileChownRequest;
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutFileChmodRequest {
    ///Mode in octal permission format
    #[validate(length(min = 1))]
    pub mode: String,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutFileChmodResponse {
    pub output: Option<File>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct PutFileChownRequest {
    ///Group name of the new group owner of the file
    #[default(Some(String::new()))]
    pub group: Option<String>,
    ///User name of the new user owner of the file
    #[default(Some(String::new()))]
    pub owner: Option<String>,
    #[serde(rename = "sourcePath")]
    pub source_path: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct PutFileChownResponse {
    pub output: Option<File>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct ReservationModel {
    #[serde(rename = "endTime")]
    pub end_time: i64,
    pub features: Option<String>,
    #[validate(length(min = 1))]
    pub name: String,
    #[serde(rename = "nodeList")]
    #[validate(length(min = 1))]
    pub node_list: String,
    #[serde(rename = "startTime")]
    pub start_time: i64,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3DataTransferDirective {
    #[serde(rename = "completeUploadUrl")]
    pub complete_upload_url: Option<String>,
    #[serde(rename = "downloadUrl")]
    pub download_url: Option<String>,
    ///Size of the file to upload in bytes
    #[serde(rename = "fileSize")]
    pub file_size: Option<i64>,
    #[serde(rename = "maxPartSize")]
    pub max_part_size: Option<i64>,
    #[serde(rename = "partsUploadUrls")]
    pub parts_upload_urls: Option<Vec<String>>,
    #[serde(rename = "transferMethod")]
    #[validate(length(min = 1))]
    #[default("s3".to_string())]
    pub transfer_method: String,
}
///Object storage configuration, including credentials, endpoints, and upload behavior.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3DataTransferInput {
    ///Access key ID for S3-compatible storage.
    #[serde(rename = "accessKeyId")]
    #[validate(length(min = 1))]
    pub access_key_id: String,
    ///Configuration for automatic object lifecycle in storage buckets.
    #[serde(rename = "bucketLifecycleConfiguration")]
    pub bucket_lifecycle_configuration: Option<BucketLifecycleConfiguration>,
    ///Configuration for multipart upload behavior.
    pub multipart: Option<MultipartUpload>,
    ///Name identifier for the storage.
    #[validate(length(min = 1))]
    pub name: String,
    ///Private/internal endpoint URL for the storage.
    #[serde(rename = "privateUrl")]
    #[validate(length(min = 1))]
    pub private_url: String,
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    ///Public/external URL for the storage.
    #[serde(rename = "publicUrl")]
    #[validate(length(min = 1))]
    pub public_url: String,
    ///Region of the storage bucket.
    #[validate(length(min = 1))]
    pub region: String,
    ///Secret access key for storage. You can give directly the content or the file path using `'secret_file:/path/to/file'`.
    #[serde(rename = "secretAccessKey")]
    #[validate(length(min = 1))]
    pub secret_access_key: String,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1))]
    #[default("s3".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
    ///Optional tenant identifier for multi-tenant setups.
    pub tenant: Option<String>,
    ///Time-to-live (in seconds) for generated URLs.
    pub ttl: i64,
}
///Object storage configuration, including credentials, endpoints, and upload behavior.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct S3DataTransferOutput {
    ///Access key ID for S3-compatible storage.
    #[serde(rename = "accessKeyId")]
    #[validate(length(min = 1))]
    pub access_key_id: String,
    ///Configuration for automatic object lifecycle in storage buckets.
    #[serde(rename = "bucketLifecycleConfiguration")]
    pub bucket_lifecycle_configuration: Option<BucketLifecycleConfiguration>,
    ///Configuration for multipart upload behavior.
    pub multipart: Option<MultipartUpload>,
    ///Name identifier for the storage.
    #[validate(length(min = 1))]
    pub name: String,
    ///Private/internal endpoint URL for the storage.
    #[serde(rename = "privateUrl")]
    #[validate(length(min = 1))]
    pub private_url: String,
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    ///Public/external URL for the storage.
    #[serde(rename = "publicUrl")]
    #[validate(length(min = 1))]
    pub public_url: String,
    ///Region of the storage bucket.
    #[validate(length(min = 1))]
    pub region: String,
    ///Secret access key for storage. You can give directly the content or the file path using `'secret_file:/path/to/file'`.
    #[serde(rename = "secretAccessKey")]
    #[validate(length(min = 1))]
    pub secret_access_key: String,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1))]
    #[default("s3".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
    ///Optional tenant identifier for multi-tenant setups.
    pub tenant: Option<String>,
    ///Time-to-live (in seconds) for generated URLs.
    pub ttl: i64,
}
///Health status of S3-compatible storage.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct S3ServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: HealthCheckType,
}
///Cluster job scheduler configuration.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct Scheduler {
    ///REST API endpoint for scheduler.
    #[serde(rename = "apiUrl")]
    pub api_url: Option<String>,
    ///Scheduler API version.
    #[serde(rename = "apiVersion")]
    pub api_version: Option<String>,
    ///Timeout in seconds for scheduler communication with the API.
    #[default(Some(10i64))]
    pub timeout: Option<i64>,
    ///Supported job scheduler types.
    #[serde(rename = "type")]
    pub r#type: SchedulerType,
    ///Scheduler version.
    #[validate(length(min = 1))]
    pub version: String,
}
///Health check result for the job scheduler.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct SchedulerServiceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: HealthCheckType,
}
///Supported job scheduler types.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
pub enum SchedulerType {
    #[serde(rename = "slurm")]
    #[default]
    Slurm,
    #[serde(rename = "pbs")]
    Pbs,
}
///Internal service account credentials.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct ServiceAccount {
    ///Service account client ID.
    #[serde(rename = "clientId")]
    #[validate(length(min = 1))]
    pub client_id: String,
    ///Service account secret token. You can give directly the content or the file path using `'secret_file:/path/to/file'`.
    #[validate(length(min = 1))]
    pub secret: String,
}
///SSH connection pool configuration for remote execution.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct SshclientPool {
    ///SSH target hostname.
    #[validate(length(min = 1))]
    pub host: String,
    ///Maximum number of concurrent SSH clients.
    #[serde(rename = "maxClients")]
    #[default(Some(100i64))]
    pub max_clients: Option<i64>,
    ///SSH port.
    pub port: i64,
    ///Optional proxy host for tunneling.
    #[serde(rename = "proxyHost")]
    pub proxy_host: Option<String>,
    ///Optional proxy port.
    #[serde(rename = "proxyPort")]
    pub proxy_port: Option<i64>,
    ///Various SSH settings.
    pub timeout: Option<Sshtimeouts>,
}
///Health status of SSH service.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct SshserviceHealth {
    ///True if the service is healthy.
    #[default(Some(false))]
    pub healthy: Option<bool>,
    ///Timestamp of the last health check.
    #[serde(rename = "lastChecked")]
    pub last_checked: Option<chrono::DateTime<chrono::Utc>>,
    ///Service response latency in seconds.
    pub latency: Option<f64>,
    ///Optional status message.
    pub message: Option<String>,
    ///Types of services that can be health-checked.
    #[serde(rename = "serviceType")]
    pub service_type: HealthCheckType,
}
///Various SSH settings.
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct Sshtimeouts {
    ///Timeout (seconds) for executing commands over SSH.
    #[serde(rename = "commandExecution")]
    #[default(Some(5i64))]
    pub command_execution: Option<i64>,
    ///Timeout (seconds) for initial SSH connection.
    #[default(Some(5i64))]
    pub connection: Option<i64>,
    ///Max idle time (seconds) before disconnecting.
    #[serde(rename = "idleTimeout")]
    #[default(Some(60i64))]
    pub idle_timeout: Option<i64>,
    ///Interval (seconds) for sending keep-alive messages.
    #[serde(rename = "keepAlive")]
    #[default(Some(5i64))]
    pub keep_alive: Option<i64>,
    ///Timeout (seconds) for SSH login/auth.
    #[default(Some(5i64))]
    pub login: Option<i64>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct UploadFileResponse {
    ///Provide method specific transfer directives
    #[serde(rename = "transferDirectives")]
    pub transfer_directives: Option<UploadFileResponseTransferDirectives>,
    #[serde(rename = "transferJob")]
    pub transfer_job: FirecrestFilesystemTransferModelsTransferJob,
}
///Provide method specific transfer directives
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, oas3_gen_support::Default)]
#[serde(tag = "transferMethod")]
pub enum UploadFileResponseTransferDirectives {
    #[serde(rename = "s3")]
    #[default]
    S3DataTransferDirective(S3DataTransferDirective),
    #[serde(rename = "wormhole")]
    WormholeDataTransferDirective(WormholeDataTransferDirective),
}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
pub struct UserInfoResponse {
    pub group: PosixIdentified,
    pub groups: Vec<PosixIdentified>,
    pub user: PosixIdentified,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeDataTransferDirective {
    #[serde(rename = "transferMethod")]
    #[validate(length(min = 1))]
    #[default("wormhole".to_string())]
    pub transfer_method: String,
    #[serde(rename = "wormholeCode")]
    pub wormhole_code: Option<String>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeDataTransferInput {
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1))]
    #[default("wormhole".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
}
#[oas3_gen_support::skip_serializing_none]
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, validator::Validate, oas3_gen_support::Default)]
#[serde(default)]
pub struct WormholeDataTransferOutput {
    ///Configuration for probing storage availability.
    pub probing: Option<Probing>,
    #[serde(rename = "serviceType")]
    #[validate(length(min = 1))]
    #[default("wormhole".to_string())]
    pub service_type: String,
    ///Optional health information for different services in the cluster.
    #[serde(rename = "servicesHealth")]
    pub services_health: Option<Vec<S3ServiceHealth>>,
}

fn main() {}
